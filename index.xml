<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fr13ndSDP&#39;s Blog</title>
    <link>https://fr13ndsdp.github.io/</link>
    <description>Recent content on Fr13ndSDP&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 24 Jun 2020 16:52:41 +0800</lastBuildDate>
    
	<atom:link href="https://fr13ndsdp.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ODE in OpenFOAM</title>
      <link>https://fr13ndsdp.github.io/post/ode-in-openfoam/</link>
      <pubDate>Wed, 24 Jun 2020 16:52:41 +0800</pubDate>
      
      <guid>https://fr13ndsdp.github.io/post/ode-in-openfoam/</guid>
      <description>OpenFOAM 中求解 ODE 一例 作者：邱小平
本篇介绍如何编写一个小程序来调用 OpenFOAM 的 ODE 求解器来求解任意常微分方程的初值问题。
1. 数学背景 首先简要看一下涉及的数学背景。对于一阶的常微分方程， $$ y’=f(x,y), \quad x\in[a,b] \
y(a)=y_0 $$ 常微分方程，如果存在解析解的话，其解应该是一个函数 $y=f(x)$。然而，大多数常微分方程是没有解析解的，只能数值求解。数值方法得到的，是一系列的 $x_0, x_1, \cdots x_n$ 对应的函数值 $y_0, y_1, \cdots y_n$。
常用的数值解法有：
  显式欧拉法 这种方法最简单，将区间 $[a,b]$ 分成 n 份，则得到步长 $h=(b-a)/n$。以 $y(a)=y_0$ 为起点，通过下述迭代， $$ y_{m+1} = y_m+hf(x_m,y_m) $$ 可以得到 $x_m=a+m*h$ 处的函数值 $y_m$，此即为常微分方程的数值解。显式欧拉法形式简单，但是只有一阶精度，而且稳定性是有条件的，一般在实际中较少用到。
  改进的欧拉法 这种方法是在显式欧拉法的基础上改进得到，将显式欧拉法中使用的向前积分改为梯形积分。其迭代形式为 $$ y_{m+1} = y_m +\frac{h}{2}[f(x_m,y_m)+f(x_{m+1},y_{m+1})] $$ 这种方法不是显式地，所以，需要在每一步内进行迭代求解。可以用如下的迭代公式 $$ y_{m+1}^{(n+1)} = y_m +\frac{h}{2}[f(x_m,y_m)+f(x_{m+1},y_{m+1}^{(n)})] $$ 注意，这里的 n 指的是计算 $y_{m+1}$ 的值时的内迭代次数，迭代的初始值 $y_{m+1}^{(0)}$ 可以用显式欧拉公式来给出 $$ y_{m+1}^{(0)} = y_m + hf(x_m, y_m) $$</description>
    </item>
    
    <item>
      <title>Vscode 4 openfoam</title>
      <link>https://fr13ndsdp.github.io/post/vscode-4-openfoam/</link>
      <pubDate>Wed, 24 Jun 2020 15:56:48 +0800</pubDate>
      
      <guid>https://fr13ndsdp.github.io/post/vscode-4-openfoam/</guid>
      <description>Vscode For OpenFOAM 介绍 使用现代化的编辑器vscode进行OpenFOAM编程的配置，大大提升编程体验。
说明  首先搜索扩展c/c++安装如下的C++扩展：   打开工作文件夹，即你的OpenFOAM求解器存放的文件夹，按住shift+ctrl+p开启命令框，输入c/c++:conf后选择如图的第二条命令，生成.vscode/c_cpp_properties.json   打开Make/options，可以看到所有需要包含的头文件，以-I开头  值得注意的是，其中的$(LIB_SRC)所指的地址就是OpenFOAM源代码路径。
如果你不知道这个路径，终端下执行
src pwd 打印出的内容就是$LIB_SRC
值得注意的是，Make/options中的头文件并不完整，还需要加入以下两个头文件：
/opt/OpenFOAM/OpenFOAM-v1912/USERNAME/src/OpenFOAM/lnInclude /opt/OpenFOAM/OpenFOAM-v1912/USERNAME/src/OSspecific/POSIX/lnInclude 请自行搜索以上两个头文件在你的设备中的位置。
 接着把完整路径放到C++配置文件的includePath中：  注意每条路径用&amp;quot; &amp;quot;括起来，行末加,（最后一行路径除外）
 接下来还有一些小工作要做，先wmake求解器，你会看到下面的输出：  第一个参数g++说明wmake使用g++编译器，因此将g++的路径替换compilerPath中的内容，不知道g++路径？终端里which g++得到。后面-std = c++11 -m64 ... -ftemplate-depth-100是compilerArgs， 大部分是规定了编译过程错误信息输出以及优化信息，其中，-W开头的参数规定了编译过程中错误信息如何输出，对于我们使用编辑器没有作用，-std = c++ 11 -m64 -O3这几个参数则规定了编译使用的C++标准和优化信息，可以保留，而 以-D参数开头的是一些宏定义，他们有的规定了所使用的精度等级，这些定义十分重要，如果不加会引起类型错误。最后-ftemplate-depth-100规定了实例化搜寻深度，默认值为900，所以如果不加应该也没有问题，但是对性能的影响尚不清楚。 如果你觉得太麻烦，你可以将他们全都加到compilerArgs里
 最终效果：  自动补全，代码提示、跳转都正常
 NOTE   由于OpenFOAM”特殊“的编程风格，常在头文件中写代码段而不是类声明等常规写法，会导致报错，比如头文件中runTime的undefined错误提示和Info的ambigous提示，目前没有解决方法。如果你不想看到这些错误提示，可以设置忽略，具体方法在网上很容易找到
  OpenFOAM的.C .H后缀可能使得Vscode识别语言类型错误，可以在.vscode下创建settings.json设置类型绑定，具体方法在网上很容易找到
  由于C++扩展进行intellisense会占用较大的存储空间，每打开一个工程，就会相应生成一个100Mb左右的预编译文件，但是对于intellisense没有作用。可以定期清理~/.cache/vscode-cpptools/ipch下的缓存文件来释放空间，或者在设置中把intellisense cache size设为0禁用。
  如果是wsl用户，可以使用wsl插件在vscode中调用bash，上述操作均在vscode连接Ubuntu后进行
   如果遇到问题请点我发起issue   LICENSE 本内容基于CC-BY-4.</description>
    </item>
    
  </channel>
</rss>