[{"content":"\n由于大创，被迫复习51单片机:sob:\n\n\u0026lt;!--more--\u0026gt;\n\n### 测量参数\n\n测量范围：20-90% RH 0-50℃\n\n测湿精度：±5% RH\n\n测温精度：±2℃\n\n分辨力：1\n\n### 特性\n\n- 宽电压供电，3V~5.5V\n- 数据线接上拉电阻，当长度小于20m，使用5k电阻\n- 上电后有1s的不稳定状态\n\n### 时序\n\n{{\u0026lt; figure src=\u0026#34;/images/DHT11/sequential.png\u0026#34; title=\u0026#34;时序\u0026#34; \u0026gt;}}\n\n#### 1. 起始信号\n\n总线空闲状态为高电平，主机把总线拉低等待DHT11响应；\n\n与MCU相连的SDA数据引脚置为输出模式；\n\n主机把总线拉低至少18毫秒，然后拉高20-40us等待DHT返回响应信号；\n\n#### 2. 读取DHT11响应\n\nSDA数据引脚设为输入模式；\n\nDHT11检测到起始信号后，会将总线拉低80us，然后拉高80us作为响应；\n\n#### 3. 送出数据\n\nDHT11将送出40bit的数据\n\n**格式**: 40bit数据=8位湿度整数+8位湿度小数+8位温度整数+8位温度小数+8位校验\n\n\n\n```c\n#include \u0026lt;reg51.h\u0026gt;\n#include \u0026lt;intrins.h\u0026gt;\n\n#define uchar unsigned char\n#define uint unsigned int\n\nsbit Data=P1^0;   //定义数据线\nuchar rec_dat[12];   //用于显示的接收数据数组\n\nvoid UART_init()\n{\n    SCON = 0X50;\n    TMOD = 0X20;\n    TH1 = 0XFD;\n    TL1 = 0XFD;\n\n    TR1 = 1;\n}\n\nvoid UART_send_byte(uchar dat)\n{\n    SBUF = dat;\n    while (TI == 0); \n    TI = 0;\n}\n\nvoid UART_send_string(uchar *buf)\n{\n    while (*buf != \u0026#39;0\u0026#39;)\n    {\n        UART_send_byte(*buf++);\n    }\n}\n\nvoid delay()\n{\n    uchar m,n,s;\n    for (m=20;m\u0026gt;0;m--)\n    {\n        for (n=20;n\u0026gt;0;n--)\n        {\n            for (s=120;s\u0026gt;0;s--);\n        }\n    }\n}\n\nvoid DHT11_delay_us(uchar n)\n{\n    while(--n);\n}\n\nvoid DHT11_delay_ms(uint z)\n{\n   uint i,j;\n   for(i=z;i\u0026gt;0;i--)\n      for(j=110;j\u0026gt;0;j--);\n}\n\nvoid DHT11_start()\n{\n   Data=1;\n   DHT11_delay_us(2);\n   Data=0;\n   DHT11_delay_ms(20);   //延时18ms以上\n   Data=1;\n   DHT11_delay_us(30);\n}\n\nuchar DHT11_rec_byte()      //接收一个字节\n{\n   uchar i,dat=0;\n  for(i=0;i\u0026lt;8;i++)    //从高到低依次接收8位数据\n   {          \n      while(!Data);   ////等待50us低电平过去\n      DHT11_delay_us(8);     //延时60us，如果还为高则数据为1，否则为0 \n      dat\u0026lt;\u0026lt;=1;           //移位使正确接收8位数据，数据为0时直接移位\n      if(Data==1)    //数据为1时，使dat加1来接收数据1\n         dat+=1;\n      while(Data);  //等待数据线拉低    \n    }  \n    return dat;\n}\n\nvoid DHT11_receive()      //接收40位的数据\n{\n    uchar R_H,R_L,T_H,T_L,RH,RL,TH,TL,revise; \n    DHT11_start();\n    if(Data==0)\n    {\n        while(Data==0);   //等待拉高     \n        DHT11_delay_us(40);  //拉高后延时80us\n        R_H=DHT11_rec_byte();    //接收湿度高八位  \n        R_L=DHT11_rec_byte();    //接收湿度低八位  \n        T_H=DHT11_rec_byte();    //接收温度高八位  \n        T_L=DHT11_rec_byte();    //接收温度低八位\n        revise=DHT11_rec_byte(); //接收校正位\n\n        DHT11_delay_us(25);    //结束\n\n        if((R_H+R_L+T_H+T_L)==revise)      //校正\n        {\n            RH=R_H;\n            RL=R_L;\n            TH=T_H;\n            TL=T_L;\n        } \n        /*数据处理，方便显示*/\n        /*\n        rec_dat[0]=\u0026#39;0\u0026#39;+(TH/10);\n        rec_dat[1]=\u0026#39;0\u0026#39;+(TH%10);\n        rec_dat[2]=\u0026#39;.\u0026#39;;\n        rec_dat[3]=\u0026#39;0\u0026#39;+(TL/10);\n        rec_dat[4]=\u0026#39;0\u0026#39;+(TL%10);\n        rec_dat[5]=\u0026#39;C\u0026#39;;\n        rec_dat[6]=\u0026#39;\\r\u0026#39;;\n        rec_dat[7]=\u0026#39;\\n\u0026#39;;\n        */\n        rec_dat[0]=\u0026#39;l\u0026#39;;\n        rec_dat[1]=\u0026#39;=\u0026#39;;\n        rec_dat[2]=\u0026#39;0\u0026#39;+(RH/10);\n        rec_dat[3]=\u0026#39;0\u0026#39;+(RH%10);\n        rec_dat[4]=\u0026#39;,\u0026#39;;\n        rec_dat[5]=\u0026#39;x\u0026#39;;\n        rec_dat[6]=\u0026#39;=\u0026#39;;\n        rec_dat[7]=\u0026#39;0\u0026#39;+(TH/10);\n        rec_dat[8]=\u0026#39;0\u0026#39;+(TH%10);\n        rec_dat[9]=\u0026#39;\\r\u0026#39;;\n        rec_dat[10] = \u0026#39;\\n\u0026#39;;\n        rec_dat[11] = \u0026#39;0\u0026#39;;\n    }\n}\n\nvoid main()\n{\n   UART_init();\n   DHT11_delay_ms(1500);    //DHT11上电后要等待1S以越过不稳定状态在此期间不能发送任何指令\n   while(1)\n   {\n       DHT11_receive();\n       UART_send_string(rec_dat);\n       UART_send_byte(\u0026#39;\\r\u0026#39;);\n       UART_send_byte(\u0026#39;\\n\u0026#39;);\n       delay();\n       //delay();\n   }\n}\n```","date":"2020-06-30","description":"","objectID":"/dht11/","tags":"DHT11","title":"DHT11温度传感器——51单片机","uri":"/dht11/"},{"content":"最佳解法：广度优先搜素\n\u0026lt;!--more--\u0026gt;\n\n\u0026gt; 给你一个由 `\u0026#39;1\u0026#39;`（陆地）和 `\u0026#39;0\u0026#39;`（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\u0026gt;\n\u0026gt; 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。\n\u0026gt;\n\u0026gt; 此外，你可以假设该网格的四条边均被水包围。\n\n示例:\n\n```\n输入:\n11110\n11010\n11000\n00000\n输出: 1\n```\n\n```\n输入:\n11000\n11000\n00100\n00011\n输出: 3\n解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。\n```\n\n**思路**：\n\n- 扫描一遍整个网格，遇到陆地就对他广度优先搜索，并将搜索到的全部陆地置为`0`，这样执行搜索的次数便是岛屿的数量。\n\n- 使用队列实现广搜，按照距离根节点距离递增的顺序遍历节点，遇到陆地则该点坐标入队，同时其上一个节点坐标出队，当队列为空时搜索完成。\n- 坐标点表示使用STL容器`pair\u0026lt;int,int\u0026gt;`，头文件`utility`\n- 时间复杂度$O(MN)$，扫描二维网格的时间复杂度\n- 最坏情况为全是陆地，因此空间复杂度$O(min(M,N))$\n\n**实现**\n\n```c++\nclass Solution {\npublic:\n    int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) {\n        int nr = grid.size();\n        // 经典陷阱\n        if (nr == 0)\n            return 0;\n        int nc = grid[0].size();\n        int num = 0;\n\n        for (int r=0; r \u0026lt; nr; r++) {\n            for (int c=0; c \u0026lt; nc; c++) {\n                if (grid[r][c] == \u0026#39;1\u0026#39;) {\n                    // 遇到根节点为陆地，岛屿加一\n                    num++;\n                    grid[r][c] = \u0026#39;0\u0026#39;;\n                    // 节点坐标\n                    queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; q;\n                    q.push({r,c});\n                    // 广搜\n                    while(!q.empty()) {\n                        auto rc = q.front();\n                        int row = rc.first, col = rc.second;\n                        // 访问四个邻接点\n                        if (row+1 \u0026lt; nr \u0026amp;\u0026amp; grid[row+1][col] == \u0026#39;1\u0026#39;) {\n                            grid[row+1][col] = \u0026#39;0\u0026#39;;\n                            q.push({row+1,col});\n                        }\n                        if (row-1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[row-1][col] == \u0026#39;1\u0026#39;) {\n                            grid[row-1][col] = \u0026#39;0\u0026#39;;\n                            q.push({row-1,col});\n                        }\n                        if (col+1 \u0026lt; nc \u0026amp;\u0026amp; grid[row][col+1] == \u0026#39;1\u0026#39;) {\n                            grid[row][col+1] = \u0026#39;0\u0026#39;;\n                            q.push({row,col+1});\n                        }\n                        if (col-1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[row][col-1] == \u0026#39;1\u0026#39;) {\n                            grid[row][col-1] = \u0026#39;0\u0026#39;;\n                            q.push({row,col-1});\n                        }\n                        q.pop();\n                    }\n                }\n            }\n        }\n        return num;\n    }\n};\n```\n\n**总结**\n\n广搜的实现还是较为容易，第一次做时以为只需要向根节点右下方遍历就行了，结果遇到了特例：*工字形* 的岛屿等，如\n\n```\n111\n010\n111\n```\n\n若是只向右下方搜索就会得出岛屿为2。\n\n","date":"2020-06-28","description":"","objectID":"/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/","tags":"广度优先搜索\n队列","title":"#200 岛屿数量","uri":"/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"},{"content":"\n使用HUGO+Github Pages搭建个人博客\n\n\u0026lt;!--more--\u0026gt;\n\n## 安装HUGO\n\n由于WSL2的LocalHost和主机不一样，导致没办法本地预览，我放弃了在WSL上安装hugo，而是安装在Windows上，然后通过WSL调用`hugo.exe`来完成工作流。\n\n在 [HUGO的github仓库](https://github.com/gohugoio/hugo/) 下载windows Release版本，由于下载的很慢，我使用github镜像 [link](https://github.wuyanzheshui.workers.dev/) 来下载然后把hugo.exe的路径添加到系统环境变量。终端里执行\n\n```bash\nhugo.exe version\n```\n\n打印版本信息，一切正常。\n\n## 配置\n```bash\nhugo new site /path/to/site\n```\n\n后，将建立一个文件夹，结构如下\n\n```\n.\n├── archetypes\n├── config.toml\n├── content\n├── data\n├── layouts\n├── resources\n├── static\n└── themes\n```\n\n首先要安装一个主题，我选择了`LoveIt`主题，[仓库地址](https://github.com/dillonzq/LoveIt/ )。\n\n```bash\ngit clone git@github.com:dillonzq/LoveIt.git themes/LoveIt\n```\n\n然后需要编辑`config.toml`，我直接把`/themes/LoveIt/exampleSite`里的给复制了过来，然后略加一点修改就行了。注释非常详尽，参照着改就行了。[link](https://hugoloveit.com/)的文档就更加详尽了，以后遇到坑再看吧。\n\n`static`用来放图片，`aechetypes`里的`default.md`在每次创建文章的时候自动加一个模板。\n\n## 发布内容\n\n```bash\nhugo new posts/post.md\n```\n确认要发布后，然后把`draft:true` 改为`false`\n\n然后\n\n```bash\nhugo server\n```\n\n就可以在1313端口预览网页了。\n\n## 部署到Github Pages\n\n1. 创建github仓库，名字为`UserName.github.io`\n2. 进入`public`文件夹，执行`git init`，`git remote add xxx`\n3. 将`public`文件夹内容`push`到github\n\n","date":"2020-06-24","description":"","objectID":"/hugo-go/","tags":"HUGO","title":"HUGO搭建博客","uri":"/hugo-go/"},{"content":"\n\u0026gt; 西安交通大学能源与动力工程本科在读\n\n","date":"2019-08-02","description":"","objectID":"/about/","tags":"","title":"关于 Fr13ndSDP","uri":"/about/"}]