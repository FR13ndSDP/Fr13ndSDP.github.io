[{"content":"最佳解法：广度优先搜素\n\u0026lt;!--more--\u0026gt;\n\n\u0026gt; 给你一个由 `\u0026#39;1\u0026#39;`（陆地）和 `\u0026#39;0\u0026#39;`（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\u0026gt;\n\u0026gt; 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。\n\u0026gt;\n\u0026gt; 此外，你可以假设该网格的四条边均被水包围。\n\n示例:\n\n```\n输入:\n11110\n11010\n11000\n00000\n输出: 1\n```\n\n```\n输入:\n11000\n11000\n00100\n00011\n输出: 3\n解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。\n```\n\n**思路**：\n\n- 扫描一遍整个网格，遇到陆地就对他广度优先搜索，并将搜索到的全部陆地置为`0`，这样执行搜索的次数便是岛屿的数量。\n\n- 使用队列实现广搜，按照距离根节点距离递增的顺序遍历节点，遇到陆地则该点坐标入队，同时其上一个节点坐标出队，当队列为空时搜索完成。\n- 坐标点表示使用STL容器`pair\u0026lt;int,int\u0026gt;`，头文件`utility`\n- 时间复杂度$O(MN)$，扫描二维网格的时间复杂度\n- 空间复杂度$O(min(M,N)$，还不是太清除\n\n**实现**\n\n```c++\nclass Solution {\npublic:\n    int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) {\n        int nr = grid.size();\n        // 经典陷阱\n        if (nr == 0)\n            return 0;\n        int nc = grid[0].size();\n        int num = 0;\n\n        for (int r=0; r \u0026lt; nr; r++) {\n            for (int c=0; c \u0026lt; nc; c++) {\n                if (grid[r][c] == \u0026#39;1\u0026#39;) {\n                    // 遇到根节点为陆地，岛屿加一\n                    num++;\n                    grid[r][c] = \u0026#39;0\u0026#39;;\n                    // 节点坐标\n                    queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; q;\n                    q.push({r,c});\n                    // 广搜\n                    while(!q.empty()) {\n                        auto rc = q.front();\n                        int row = rc.first, col = rc.second;\n                        // 访问四个邻接点\n                        if (row+1 \u0026lt; nr \u0026amp;\u0026amp; grid[row+1][col] == \u0026#39;1\u0026#39;) {\n                            grid[row+1][col] = \u0026#39;0\u0026#39;;\n                            q.push({row+1,col});\n                        }\n                        if (row-1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[row-1][col] == \u0026#39;1\u0026#39;) {\n                            grid[row-1][col] = \u0026#39;0\u0026#39;;\n                            q.push({row-1,col});\n                        }\n                        if (col+1 \u0026lt; nc \u0026amp;\u0026amp; grid[row][col+1] == \u0026#39;1\u0026#39;) {\n                            grid[row][col+1] = \u0026#39;0\u0026#39;;\n                            q.push({row,col+1});\n                        }\n                        if (col-1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[row][col-1] == \u0026#39;1\u0026#39;) {\n                            grid[row][col-1] = \u0026#39;0\u0026#39;;\n                            q.push({row,col-1});\n                        }\n                        q.pop();\n                    }\n                }\n            }\n        }\n        return num;\n    }\n};\n```\n\n**总结**\n\n广搜的实现还是较为容易，第一次做时以为只需要向根节点右下方遍历就行了，结果遇到了特例：*工字形* 的岛屿等，如\n\n```\n111\n010\n111\n```\n\n若是只向右下方搜索就会得出岛屿为2。\n\n","date":"2020-06-28","description":"","objectID":"/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/","tags":"广度优先搜索\n队列","title":"#200 岛屿数量","uri":"/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"},{"content":"\n作者：[邱小平](https://xiaopingqiu.github.io)\n\n本篇介绍如何编写一个小程序来调用 OpenFOAM 的 ODE 求解器来求解任意常微分方程的初值问题。\n\n\u0026lt;!--more--\u0026gt;\n\n##### 1. 数学背景\n\n首先简要看一下涉及的数学背景。对于一阶的常微分方程，\n$$ y’=f(x,y), \\quad x\\in[a,b] \\\\ y(a)=y_0 $$\n\n常微分方程，如果存在解析解的话，其解应该是一个函数 $y=f(x)$。然而，大多数常微分方程是没有解析解的，只能数值求解。数值方法得到的，是一系列的 $x_0, x_1, \\cdots x_n$ 对应的函数值 $y_0, y_1, \\cdots y_n$。\n\n常用的数值解法有：\n\n- 显式欧拉法\n  这种方法最简单，将区间 $[a,b]$ 分成 n 份，则得到步长 $h=(b-a)/n$。以 $y(a)=y_0$ 为起点，通过下述迭代，\n  $$ y_{m+1} = y_m+hf(x_m,y_m) $$\n  可以得到 $x_m=a+m*h$ 处的函数值 $y_m$，此即为常微分方程的数值解。显式欧拉法形式简单，但是只有一阶精度，而且稳定性是有条件的，一般在实际中较少用到。\n\n- 改进的欧拉法\n  这种方法是在显式欧拉法的基础上改进得到，将显式欧拉法中使用的向前积分改为梯形积分。其迭代形式为\n  $$ y_{m+1} = y_m +\\frac{h}{2}[f(x_m,y_m)+f(x_{m+1},y_{m+1})] $$\n  这种方法不是显式地，所以，需要在每一步内进行迭代求解。可以用如下的迭代公式\n  $$ y_{m+1}^{(n+1)} = y_m +\\frac{h}{2}[f(x_m,y_m)+f(x_{m+1},y_{m+1}^{(n)})] $$\n  注意，这里的 n 指的是计算 $y_{m+1}$ 的值时的内迭代次数，迭代的初始值 $y_{m+1}^{(0)}$ 可以用显式欧拉公式来给出\n  $$ y_{m+1}^{(0)} = y_m + hf(x_m, y_m) $$\n\n- 显式 4 阶 Runge-Kutta 方法\n  这是现实中常用的一种方法，其迭代形式如下\n  $$ \\begin{align*}\n  y_{m+1} \u0026amp; = y_m + \\frac{h}{6}[k_1+2k_2+2k_3+k_4] \\\\\n  k_1 \u0026amp; = f(x_m, y_m) \\\\\n  k_2 \u0026amp; = f(x_m+\\frac{1}{2}h, y_m+\\frac{1}{2}hk_1) \\\\\n  k_3 \u0026amp; = f(x_m+\\frac{1}{2}h, y_m+\\frac{1}{2}hk_2) \\\\\n  k_4\u0026amp; = f(x_m+h, y_m+hk_3)\n  \\end{align*} $$\n\n除了以上，当然还有很多方法，比如预测校正等等，这里就不再逐一介绍了。\n\n问题是，实际中遇到的还可能是高阶的常微分方程，比如，弹簧-谐振子系统可以用以下e二阶常微分方程描述\n$$\n\\frac{d^2y}{dt^2} = -\\frac{k}{m}y\n$$\n\n高阶常微分方程的初值问题，可以用以下通式来描述\n$$\ny^{n} = f(x,y,y’,\\cdots y^{n-1})\n$$\n\n其初始条件为\n$$\ny(0) = a_0, \\quad y’(0) = a_1, \\quad \\cdots, \\quad y^{n-1}(0) = a_n\n$$\n对于这种高阶常微分方程，可以将其表述为一系列一阶常微分方程的组成的方程组来求解。下面以二阶常微分方程为例，介绍如何将高阶常微分方程的初值问题转化为一阶常微分方程组。\n考察如下二阶常微分方程\n$$\ny’’ = f(x,y,y’), \\quad x\\in[a,b] \\\\\ny(a) = a_0, \\quad y’(a) = a_1\n$$\n\n若令 $z=y’$，则上述二阶常微分方程可以表示成如下方程组\n$$\n\\left \\{\n\\begin{align*}\ny’ \u0026amp;= z \\\\\nz’ \u0026amp;= f(x,y,z)\n\\end{align*}\n\\right. \\\\\ny(a)=a_0,\\quad z(a)=a_1\n$$\n\n这个方程组，就可以用前面介绍的一阶常微分方程的解法来求解了，比如，若用最简单的显式欧拉法，则\n$$\n\\begin{align*}\ny_{m+1} \u0026amp;= y_m + h z_m \\\\\nz_{m+1} \u0026amp;= z_m +hf(x_m, y_m, z_m)\n\\end{align*}\n$$\n或者用显式 4 阶 Runge-Kutta 方法\n$$\n\\begin{align*}\ny_{m+1} \u0026amp; = y_m + \\frac{h}{6}[K_1+2K_2+2K_3+K_4] \\\\\nz_{m+1} \u0026amp; = z_m + \\frac{h}{6}[M_1+2M_2+2M_3+K_4] \\\\\nK_1 \u0026amp; = z_m,\\quad M_1=f(x_m, y_m, z_m) \\\\\nK_2 \u0026amp; = z_m + \\frac{M_1}{2}, \\quad M_2 = f(x_m+\\frac{h}{2}, y_m+\\frac{K_1}{2}, z_m+\\frac{M_1}{2})\\\\\nK_3 \u0026amp; = z_m + \\frac{M_2}{2},\\quad M_3 = f(x_m+\\frac{h}{2}, y_m+\\frac{K_2}{2}, z_m+\\frac{M_2}{2})\\\\\nK_4\u0026amp; = z_m + M_3,\\quad M_4=f(x_m+h, y_m+K_3, z_m+M_3)\n\\end{align*}\n$$\n\n二阶以上的常微分方程，除了可以给出初值条件，还可以给出边值条件，比如\n$$\ny’’ = f(x,y,y’), \\quad x\\in[a,b] \\\\\ny(a) = \\alpha, \\quad y(b) = \\beta\n$$\n\n这种情况下，就无法直接将此方程转化为一阶常微分方程组了。但是，边值问题可以通过一定的方法转换成初值问题，以下给出一种：**试射法**。\n在不知道 $y’(a)$ 的情况下，不妨假设 $y’(a)=\\gamma_1$，这样，就得到了一个初值问题\n$$\ny’’ = f(x,y,y’), \\quad x\\in[a,b] \\\\\ny(a) = \\alpha, \\quad y’(a) = \\gamma_1\n$$\n解此初值问题，得到 $y(b)$ 的值 $\\beta_1$，并与 $\\beta$ 比较，如果误差足够小，则认为假设的 $y’(a)=\\gamma_1$ 是合理的。否则，就对 $\\gamma_1$ 进行修正，比如令 $\\gamma_2 = \\tfrac{\\beta}{\\beta_1}\\gamma_1$，然后再以 $y’(a)=\\gamma_2$ 为初值，继续求解初值问题。直到得到的初值问题的解$y(b)=\\beta_k$ 与 $\\beta$ 足够接近为止。\n\n上述方程可以归纳为，将初值问题转化为如下边值问题\n$$\ny’’ = f(x,y,y’), \\quad x\\in[a,b] \\\\\ny(a) = \\alpha, \\quad y’(a) = \\gamma_k, k=1,2,\\cdots\n$$\n若记问题 $y_k(x)$ 的解为 $y(x;\\gamma_k)$，则 $\\gamma_k$ 的理想值应该满足\n$$\nF(\\gamma) = y(b;\\gamma)-\\beta = 0\n$$\n这个方程，可以用牛顿迭代法来求解：\n$$\n\\gamma_{k+1} = \\gamma_k-\\frac{F(\\gamma_k)}{F’(\\gamma_k)}\n$$\n其中，$F(\\gamma_k)=y(b;\\gamma_k)-\\beta=\\beta_k-\\beta$。那么 $F’(\\gamma_k)$ 该如何得到呢？根据 $F(\\gamma_k)$ 的定义，可以知道 $F’(\\gamma_k) = \\frac{\\partial y(b;\\gamma)}{\\partial \\gamma}\\big|_{\\gamma=\\gamma_k}$，若定义 $W=\\frac{\\partial y(b;\\gamma)}{\\partial \\gamma}$，则 $F’(\\gamma_k)=W(b;\\gamma_k)$。\n\n将上述归纳形式的初值问题，对$\\gamma$ 求偏导，得\n$$\n\\frac{\\partial y’’}{\\partial \\gamma} = \\frac{\\partial f(x,y(x;\\gamma),y’(x,y’))}{\\partial y} \\frac{\\partial y(x;\\gamma)}{\\partial \\gamma} + \\frac{\\partial f(x,y(x;\\gamma),y’(x,y’))}{\\partial y’} \\frac{\\partial y’(x,y’)}{\\partial \\gamma}\n$$\n\n根据 $W$ 的定义，有\n$$\nW=\\frac{\\partial y(x;\\gamma)}{\\partial \\gamma}, W’=\\frac{\\partial y’(x,y’)}{\\partial \\gamma}, W’’=\\frac{\\partial y’’}{\\partial \\gamma}\n$$\n\n于是，可以得到一个关于 $W$ 的二阶常微分方程\n$$\nW’’=\\frac{\\partial f(x,y,y’)}{\\partial y} W + \\frac{\\partial f(x,y,y’)}{\\partial y’}W’\n$$\n其定解条件为\n$$\nW(a)=\\frac{\\partial y(a;\\gamma)}{\\partial \\gamma}=0, W’(a)=\\frac{\\partial y’(a;\\gamma)}{\\partial \\gamma}=\\frac{\\partial \\gamma}{\\partial \\gamma} = 1\n$$\n\n这样就构成了一个关于 $W$ 的二阶初值常微分方程。\n总结一下，二阶常微分方程的边值问题\n$$\ny’’ = f(x,y,y’), \\quad x\\in[a,b] \\\\\ny(a) = \\alpha, \\quad y(b) = \\beta\n$$\n的求解步骤如下：\n\n1. 假定一个 $\\gamma_1$ 值，求解初值问题\n   $$\n   y’’ = f(x,y,y’), \\quad x\\in[a,b] \\\\\n   y(a) = \\alpha, \\quad y’(a) = \\gamma_1\n   $$\n   然后计算 $F(\\gamma_1)=y(b;\\gamma_1)$\n2. 求解关于 $W$ 的初值问题\n   $$\n   W’’=\\frac{\\partial f(x,y,y’)}{\\partial y} W + \\frac{\\partial f(x,y,y’)}{\\partial y’}W’ \\\\\n   W(a) = 0, W’(a) = 1\n   $$\n   然后计算 $F’(\\gamma_1) = W(b;\\gamma_1)$。\n3. 更新$\\gamma$ 的值，\n   $$\n   \\gamma_2 = \\gamma_1-\\frac{F(\\gamma_1)}{F’(\\gamma_1)}\n   $$\n   继续迭代，直到最后得到的 $y(b;\\gamma_k)$ 与 $\\beta$ 足够接近为止。\n\n##### 2. OpenFOAM 中的实现\n\n为了在OpenFOAM中求解一个任意阶常微分方程的初值问题，需要做如下准备。\n考虑一个通用形式的常微分方程\n$$\ny^{n}=f(x,y,y’,\\cdots,y^{n-1})\n$$\n定义\n$$  y_","date":"2020-06-24","description":"","objectID":"/ode-in-openfoam/","tags":"OpenFOAM","title":"ODE in OpenFOAM","uri":"/ode-in-openfoam/"}]