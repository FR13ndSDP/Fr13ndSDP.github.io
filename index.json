[{"content":"\nSIMPLE 算法在一维稳态无粘不可压流动问题中的应用\n\n\u0026lt;!--more--\u0026gt;\n\n#### 1.问题描述\n\n![](/images/simple-algorithm/problem.jpg)\n\n- 流体密度 $\\rho = 1\\ kg/m^3$, 不可压缩，无粘流动\n- 喷管长度 $L = 0.2\\ m$\n- 喷管左右面积给定 $A_{A} = 0.5\\ m^2, A_{E} = 0.1\\ m^2$\n- 左边界：恒定动压 $10\\ Pa$，右边界：恒定静压$0\\ Pa$\n\n#### 2.控制方程\n\n- 质量守恒方程\n  \n  $$\n  \\frac{d}{dx}(\\rho A u) = 0\n  $$\n  \n- 动量方程\n  $$\n  \\rho u A \\frac{du}{dx} = -A\\frac{dp}{dx}\n  $$\n\n解析解可由伯努利定律得到\n$$\np_0 = p_E + 1/2\\rho M^2/(\\rho A_E)^2\n$$\n其中$M$为质量流量，可得到精确解为$0.44271\\ kg/s$\n\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# the TDMA\ndef sol(aw, ap, ae, su):\n    n = np.size(aw)\n    p = np.zeros(n)\n    q = np.zeros(n)\n    phi = np.zeros(n)\n    p[0] = ae[0]/ap[0]\n    q[0] = su[0]/ap[0]\n    for i in range(1, n):\n        p[i] = ae[i]/(ap[i] - aw[i]*p[i-1])\n        q[i] = (su[i] + aw[i]*q[i-1])/(ap[i]-aw[i]*p[i-1])\n\n    phi[n-1] = q[n-1]\n    for i in range(n-1, 0, -1):\n        phi[i-1] = p[i-1]*phi[i]+q[i-1]\n\n    return phi\n\nrho = 1  # density\nL = 2   # length\nn = 100  # number of pressure nodals\nnu = n-1    # number of velocity nodals\ndx = L/n\np0 = 10  # inlet stagnation pressure\np_exit = 0  # oulet gauge pressure\nmass = []   # mass flow\nsp = [1]    # momentum residual (source of pressure Eq.)\nm = 1  # guessed mass flow\n\n# matrix coeff and source term coeff\napu = np.zeros(nu)\nawu = np.zeros(nu)\naeu = np.zeros(nu)\nsuu = np.zeros(nu)\napp = np.zeros(n)\nawp = np.zeros(n)\naep = np.zeros(n)\nsup = np.zeros(n)\n\n# under-relaxation factor\nalpha_u = 0.8\nalpha_p = 0.3\n\nd = np.zeros(nu)  # A/ap\n\n# area of pressure node and velocity node\nAp = np.linspace(0.5, 0.1, n)\nAu = np.linspace(0.5-0.25/n, 0.1+0.25/n, nu)\n\n# initial guessed value\nu = np.zeros(nu)\nfor i in range(nu):\n    u[i] = m/(rho*Au[i])\n\np = np.linspace(10, 0, n)\npf = np.zeros(n)  # Pressure correction value\n\nwhile(max(sp) \u0026gt; 1e-5):\n    sp = []\n    # velocity update\n    for i in range(1, nu-1):\n        awu[i] = rho*(u[i-1]+u[i])/2*Ap[i]  # F_w\n        aeu[i] = 0  # upwind scheme\n        apu[i] = rho*(u[i]+u[i+1])/2 * Ap[i+1]  # awu[i]+aeu[i]+ (F_e-F_w)\n        apu[i] = apu[i]/alpha_u  # velocity relaxation\n        suu[i] = Au[i]*(p[i]-p[i+1]) + (1-alpha_u)*apu[i]*u[i]\n        d[i] = Au[i]/apu[i]\n\n    apu[0] = rho*(u[0]+u[1])/2*Ap[1] + rho * \\\n        (u[0]*Au[0]/Ap[0])*Ap[0]*0.5*(Au[0]/Ap[0])**2\n    apu[0] = apu[0]/alpha_u  # velocity relaxation\n    suu[0] = Au[0]*(p0 - p[1])+rho*(u[0]*Au[0]/Ap[0])*Ap[0] * \\\n        (Au[0]/Ap[0])*u[0]+(1-alpha_u)*apu[0]*u[0]\n    d[0] = Au[0]/apu[0]\n\n    awu[nu-1] = rho*(u[nu-2]+u[nu-1])/2*Ap[nu-1]\n    apu[nu-1] = rho*u[nu-1]*Au[nu-1]\n    apu[nu-1] = apu[nu-1]/alpha_u  # velocity relaxation\n    suu[nu-1] = Au[nu-1]*(p[nu-1] - p[nu]) + (1-alpha_u)*apu[nu-1]*u[nu-1]\n    d[nu-1] = Au[nu-1]/apu[nu-1]\n\n    u = sol(awu, apu, aeu, suu)\n\n    # pressure update\n    for i in range(1, n-1):\n        awp[i] = rho*d[i-1]*Au[i-1]\n        aep[i] = rho*d[i]*Au[i]\n        app[i] = awp[i]+aep[i]\n        sup[i] = rho*u[i-1]*Au[i-1] - rho*u[i]*Au[i]\n        sp.append(sup[i])\n\n    # do not update boundary pressure\n    # so set app to none-zero number and set sup to zero\n    app[0] = 1\n    sup[0] = 0\n    app[n-1] = 1\n    sup[n-1] = 0\n    pf = sol(awp, app, aep, sup)\n\n    # under-relaxation of pressure\n    prev = p\n    p = p + pf\n    p[0] = p0 - 0.5*rho*u[0]*u[0]*(Au[0]/Ap[0])**2\n    p = (1-alpha_p)*prev + alpha_p*p\n\n    for i in range(nu):\n        u[i] = u[i]+d[i]*(pf[i]-pf[i+1])\n\n    # calculate mass flow\n    mass.append(rho*Au[0]*u[0])\n\nplt.figure(1)\nplt.plot(mass)\nplt.figure(2)\nplt.plot(p)\nplt.figure(3)\nplt.plot(u)\nprint(\u0026#34;mass flow:\u0026#34;, mass[-1])\nprint(\u0026#34;momentum residual:\u0026#34;, max(sp))\n```\n\n\u0026gt; mass flow: 0.45496785377760623\n\u0026gt;\n\u0026gt; momentum residual: 8.283464151048747e-06\n\n\n\n![mass flow](/images/simple-algorithm/output_1_1.png)\n\n\n\n![pressure](/images/simple-algorithm/output_1_2.png)\n\n\n\n![velocity](/images/simple-algorithm/output_1_3.png)\n\n采用压力方程中源项的绝对值的最大值作为判断收敛依据，采用100个压力节点得到收敛解：质量流量$0.455\\ kg/s$，并得到了压力、速度的分布。\n\n\n\n#### 3.参考文献\n\n- [1]  陶文铨, 数值传热学\n- [2] H.K.Versteeg, An introduction to computational fluid dynamics : the finite volume method\n- [3] J.H.Ferziger, M.Peric, Computational method for fluid dynamics","date":"2020-10-22","description":"","objectID":"/simple-algorithm/","tags":"FVM","title":"Simple algorithm","uri":"/simple-algorithm/"},{"content":"\n单调栈解法\n\n\u0026lt;!--more--\u0026gt;\n\n#### 题目\n\n请根据每日 `气温` 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。\n\n例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。\n\n提示：气温 列表长度的范围是 `[1, 30000]`。每个气温的值的均为华氏度，都是在 `[30, 100]` 范围内的整数。\n\n#### 单调栈解法\n\n维护一个栈，使得从栈底到栈顶始终是递增的，具体做法举例：\n\n假如列表`temperatures = [10,12,5,7,13,14]`\n\n- 首先10入栈，12比10大，10弹出，栈顶为12 `[12]`\n\n- 5比12小，入栈 `[12 5]`\n- 7比5大，5弹出，7入栈 `[12 7]`\n- 13比7大，7弹出，13比12大，12弹出，13入栈 `[13]`\n- 14比13大，13弹出，14入栈  `[14]`\n\n为了获取等待天数，在每个元素出栈时计算此元素与与之比较的元素的下标差。为简单起见，栈中存储下标而不是值。\n\n所以实际过程如下：\n\n{{\u0026lt; figure src=\u0026#34;/images/739-daily-temperatures/stack.jpg\u0026#34; title=\u0026#34;操作顺序\u0026#34; \u0026gt;}}\n\n代码：\n\n```c++\nclass Solution {\npublic:\n    vector\u0026lt;int\u0026gt; dailyTemperatures(vector\u0026lt;int\u0026gt;\u0026amp; T) {\n        stack\u0026lt;int\u0026gt; s;\n        int n = T.size();\n        // initionlize\n        vector\u0026lt;int\u0026gt; ans(n,0);\n        \n        for (int i=0; i\u0026lt; n; ++i) {\n            while(!s.empty() \u0026amp;\u0026amp; T[i] \u0026gt; T[s.top()]) {\n                int index = s.top();\n                // inside s are indexes\n                ans[index] = (i-s.top());\n                s.pop();\n            }\n            // got a small number, then push it to stack\n            s.push(i);\n        }\n        return ans;\n    }\n};\n```\n\n#### 复杂度分析\n\n- 时间复杂度：$O(N)$ ，温度列表的所有元素都将进栈一次\n- 空间复杂度:  $O(N)$，结果列表的长度为$N$","date":"2020-07-07","description":"","objectID":"/739-daily-temperatures/","tags":"单调栈","title":"#739 每日温度","uri":"/739-daily-temperatures/"},{"content":"\n#### 题目\n\n你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39; 。每个拨轮可以自由旋转：例如把 \u0026#39;9\u0026#39; 变为  \u0026#39;0\u0026#39;，\u0026#39;0\u0026#39; 变为 \u0026#39;9\u0026#39; 。每次旋转都只能旋转一个拨轮的一位数字。\n\n锁的初始数字为 \u0026#39;0000\u0026#39; ，一个代表四个拨轮的数字的字符串。\n\n列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。\n\n字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。\n\n```\n输入：deadends = [\u0026#34;0201\u0026#34;,\u0026#34;0101\u0026#34;,\u0026#34;0102\u0026#34;,\u0026#34;1212\u0026#34;,\u0026#34;2002\u0026#34;], target = \u0026#34;0202\u0026#34;\n输出：6\n解释：\n可能的移动序列为 \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;1000\u0026#34; -\u0026gt; \u0026#34;1100\u0026#34; -\u0026gt; \u0026#34;1200\u0026#34; -\u0026gt; \u0026#34;1201\u0026#34; -\u0026gt; \u0026#34;1202\u0026#34; -\u0026gt; \u0026#34;0202\u0026#34;。\n注意 \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;0001\u0026#34; -\u0026gt; \u0026#34;0002\u0026#34; -\u0026gt; \u0026#34;0102\u0026#34; -\u0026gt; \u0026#34;0202\u0026#34; 这样的序列是不能解锁的，\n因为当拨动到 \u0026#34;0102\u0026#34; 时这个锁就会被锁定。\n```\n\n提示：\n\n1. 死亡列表 deadends 的长度范围为 [1, 500]。\n2. 目标数字 target 不会在 deadends 之中。\n3. 每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 \u0026#39;0000\u0026#39; 到 \u0026#39;9999\u0026#39; 中产生。\n\n---\n\n#### 解法1.BFS\n\n直接BFS，不过要加一个集合来表示deadends和重复的pattern。使用`unordered_set\u0026lt;string\u0026gt;`来存储和查询。\n\n```c++\nclass Solution {\npublic:\n    string add(string s, int i)\n    {\n        if (s[i] == \u0026#39;9\u0026#39;)\n            s[i] = \u0026#39;0\u0026#39;;\n        else\n            s[i] = s[i]+1;\n        return s;\n    }\n    \n    string minus(string s, int i)\n    {\n        if (s[i] == \u0026#39;0\u0026#39;)\n            s[i] = \u0026#39;9\u0026#39;;\n        else\n            s[i] = s[i]-1;\n        return s;\n    }\n    \n    int openLock(vector\u0026lt;string\u0026gt;\u0026amp; deadends, string target) {\n        unordered_set\u0026lt;string\u0026gt; set(deadends.begin(),deadends.end());\n        if (set.find(\u0026#34;0000\u0026#34;)!=set.end())\n            return -1;\n        queue\u0026lt;string\u0026gt; q;\n        q.push(\u0026#34;0000\u0026#34;);\n        int step = 0;\n        \n        while (!q.empty())\n        {\n            int n = q.size();\n            for (int j=0; j\u0026lt;n; j++)\n            {\n                string front = q.front();\n                for (int i=0; i\u0026lt;4; i++)\n                {\n                    string a = add(front,i);\n                    if (set.find(a)!=set.end())\n                        continue;\n                    if (a == target)\n                        return step+1;\n                    if (!set.count(a))\n                    {\n                        q.push(a);\n                        set.insert(a);\n                    }\n                }\n                for (int i=0; i\u0026lt;4; i++) {\n                    string b = minus(front,i);\n                    if (set.find(b)!=set.end())\n                        continue;\n                    if (b == target)\n                        return step+1;\n                    if (!set.count(b))\n                    {\n                        q.push(b);\n                        set.insert(b);\n                    }\n                }\n                q.pop();\n            }\n            step+=1;\n        }\n        return -1;\n    }\n};\n```\n#### 解法2.双向BFS\n\n","date":"2020-07-02","description":"","objectID":"/752-open-the-lock/","tags":"广度优先搜索\n双向BFS","title":"#752 Open the Lock","uri":"/752-open-the-lock/"},{"content":"\nDHT11温湿度传感器的使用——C51代码\n\n\u0026lt;!--more--\u0026gt;\n\n### 测量参数\n\n测量范围：20-90% RH 0-50℃\n\n测湿精度：±5% RH\n\n测温精度：±2℃\n\n分辨力：1\n\n### 特性\n\n- 宽电压供电，3V~5.5V\n- 数据线接上拉电阻，当长度小于20m，使用5k电阻\n- 上电后有1s的不稳定状态\n- **DHT11 只有在接收到开始信号后才触发一次温湿度采集**，如果没有接收到主机发送复位信号，DHT11 不主动进行温湿度采集。当数据采集完毕且无开始信号后，DHT11 自动切换到低速模式。\n\n### 时序\n\n{{\u0026lt; figure src=\u0026#34;/images/DHT11/sequential.png\u0026#34; title=\u0026#34;时序\u0026#34; \u0026gt;}}\n\n#### 1. 起始信号\n\n总线空闲状态为高电平，主机把总线拉低等待DHT11响应；\n\n与MCU相连的SDA数据引脚置为输出模式；\n\n主机把总线拉低至少18毫秒，然后拉高20-40us等待DHT返回响应信号；\n\n#### 2. 读取DHT11响应\n\nSDA数据引脚设为输入模式；\n\nDHT11检测到起始信号后，会将总线拉低80us，然后拉高80us作为响应；\n\n#### 3. 送出数据\n\nDHT11将送出40bit的数据\n\n**格式**: 40bit数据=8位湿度整数+8位湿度小数+8位温度整数+8位温度小数+8位校验，当温湿度数据和等于校验位时校验通过。\n\n似乎小数位全是零，而且整数数据的计算如下例所示\n\n`00011000 00000000` = 24.0\n\n因此通过循环移位接收高八位数据后转为字符串输出即可。\n\nDHT11 在拉高总线 80us 后开始传输数据。每 1bit 数据都以 50us 低电平时隙开始，告诉主机开始传输一位数据了。DHT11 以高电平的长短定义数据位是 0 还是 1，当 50us 低电平时隙过后拉高总线，高电平持续 26~28us 表示数据“0”；持续 70us 表示数据“1”。\n\n当最后 1bit 数据传送完毕后，DHT11 拉低总线 50us，表示数据传输完毕，随后总线由上拉电阻拉高进入空闲状态。\n\n### 代码\n\n```c\n#include \u0026lt;reg51.h\u0026gt;\n#include \u0026lt;intrins.h\u0026gt;\n\n#define uchar unsigned char\n#define uint unsigned int\n\nsbit Data=P1^0;   //定义数据线\nuchar rec_dat[12];   //用于显示的接收数据数组\n\nvoid DHT11_delay_ms(uint z)\n{\n   uint i,j;\n   for(i=z;i\u0026gt;0;i--)\n      for(j=110;j\u0026gt;0;j--);\n}\n\nvoid DHT11_start()  // 开始信号\n{\n   Data=1;\n   DHT11_delay_us(2);\n   Data=0;\n   DHT11_delay_ms(20);   //延时18ms以上\n   Data=1;\n   DHT11_delay_us(30);\n}\n\nuchar DHT11_rec_byte()      //接收一个字节\n{\n   uchar i,dat=0;\n  for(i=0;i\u0026lt;8;i++)    //从高到低依次接收8位数据\n   {          \n      while(!Data);   ////等待50us低电平过去\n      DHT11_delay_us(8);     //延时60us，如果还为高则数据为1，否则为0 \n      dat\u0026lt;\u0026lt;=1;           //移位使正确接收8位数据，数据为0时直接移位\n      if(Data==1)    //数据为1时，使dat加1来接收数据1\n         dat+=1;\n      while(Data);  //等待数据线拉低    \n    }  \n    return dat;\n}\n\nvoid DHT11_receive()      //接收40位的数据\n{\n    uchar R_H,R_L,T_H,T_L,RH,RL,TH,TL,revise; \n    DHT11_start(); // 向DHT11发送开始信号\n    if(Data==0) // DHT11先拉低后拉高总线作为响应\n    {\n        while(Data==0);   //等待拉高     \n        DHT11_delay_us(40);  //拉高后延时80us\n        R_H=DHT11_rec_byte();    //接收湿度高八位  \n        R_L=DHT11_rec_byte();    //接收湿度低八位  \n        T_H=DHT11_rec_byte();    //接收温度高八位  \n        T_L=DHT11_rec_byte();    //接收温度低八位\n        revise=DHT11_rec_byte(); //接收校正位\n\n        DHT11_delay_us(25);    //结束\n\n        if((R_H+R_L+T_H+T_L)==revise)      //校正\n        {\n            RH=R_H;\n            RL=R_L;\n            TH=T_H;\n            TL=T_L;\n        } \n        /*数据处理，方便显示*/\n        rec_dat[0]=\u0026#39;l\u0026#39;;\n        rec_dat[1]=\u0026#39;=\u0026#39;;\n        rec_dat[2]=\u0026#39;0\u0026#39;+(RH/10);\n        rec_dat[3]=\u0026#39;0\u0026#39;+(RH%10);\n        rec_dat[4]=\u0026#39;,\u0026#39;;\n        rec_dat[5]=\u0026#39;x\u0026#39;;\n        rec_dat[6]=\u0026#39;=\u0026#39;;\n        rec_dat[7]=\u0026#39;0\u0026#39;+(TH/10);\n        rec_dat[8]=\u0026#39;0\u0026#39;+(TH%10);\n        rec_dat[9]=\u0026#39;\\r\u0026#39;;\n        rec_dat[10] = \u0026#39;\\n\u0026#39;;\n        rec_dat[11] = \u0026#39;0\u0026#39;;\n    }\n}\n\nvoid main()\n{\n   UART_init(); // 串口初始化\n   DHT11_delay_ms(1500);    //DHT11上电后要等待1S以越过不稳定状态在此期间不能发送任何指令\n   while(1)\n   {\n       DHT11_receive();\n       UART_send_string(rec_dat); //串口发送数据\n       delay(); // 延时一定时间\n   }\n}\n```\n\n### UART传输设置\n\n```c\nvoid UART_init()\n{\n    // 波特率9600\n    SCON = 0X50; //工作于方式1  8位无校验异步通信的收发模式，并清空收发中断标志位\n    TMOD = 0X20; // 定时器1 8位自动加载计数器\n    // 定时器初值，与波特率有关\n    TH1 = 0XFD; \n    TL1 = 0XFD; \n\n    TR1 = 1; // 启动定时器1\n}\n\nvoid UART_send_byte(uchar dat) // 发送一个字节\n{\n    SBUF = dat;\n    while (TI == 0); // 等待直到发送成功\n    TI = 0;\n}\n\nvoid UART_send_string(uchar *buf) // 发送字符串\n{\n    while (*buf != \u0026#39;0\u0026#39;)\n    {\n        UART_send_byte(*buf++);\n    }\n}\n```\n\n","date":"2020-06-30","description":"","objectID":"/dht11/","tags":"DHT11","title":"DHT11温湿度传感器——51单片机","uri":"/dht11/"},{"content":"最佳解法：广度优先搜素\n\u0026lt;!--more--\u0026gt;\n\n\u0026gt; 给你一个由 `\u0026#39;1\u0026#39;`（陆地）和 `\u0026#39;0\u0026#39;`（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\u0026gt;\n\u0026gt; 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。\n\u0026gt;\n\u0026gt; 此外，你可以假设该网格的四条边均被水包围。\n\n示例:\n\n```\n输入:\n11110\n11010\n11000\n00000\n输出: 1\n```\n\n```\n输入:\n11000\n11000\n00100\n00011\n输出: 3\n解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。\n```\n\n**思路**：\n\n- 扫描一遍整个网格，遇到陆地就对他广度优先搜索，并将搜索到的全部陆地置为`0`，这样执行搜索的次数便是岛屿的数量。\n\n- 使用队列实现广搜，按照距离根节点距离递增的顺序遍历节点，遇到陆地则该点坐标入队，同时其上一个节点坐标出队，当队列为空时搜索完成。\n- 坐标点表示使用STL容器`pair\u0026lt;int,int\u0026gt;`，头文件`utility`\n- 时间复杂度$O(MN)$，扫描二维网格的时间复杂度\n- 最坏情况为全是陆地，因此空间复杂度$O(min(M,N))$\n\n**实现**\n\n```c++\nclass Solution {\npublic:\n    int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) {\n        int nr = grid.size();\n        // 经典陷阱\n        if (nr == 0)\n            return 0;\n        int nc = grid[0].size();\n        int num = 0;\n\n        for (int r=0; r \u0026lt; nr; r++) {\n            for (int c=0; c \u0026lt; nc; c++) {\n                if (grid[r][c] == \u0026#39;1\u0026#39;) {\n                    // 遇到根节点为陆地，岛屿加一\n                    num++;\n                    grid[r][c] = \u0026#39;0\u0026#39;;\n                    // 节点坐标\n                    queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; q;\n                    q.push({r,c});\n                    // 广搜\n                    while(!q.empty()) {\n                        auto rc = q.front();\n                        int row = rc.first, col = rc.second;\n                        // 访问四个邻接点\n                        if (row+1 \u0026lt; nr \u0026amp;\u0026amp; grid[row+1][col] == \u0026#39;1\u0026#39;) {\n                            grid[row+1][col] = \u0026#39;0\u0026#39;;\n                            q.push({row+1,col});\n                        }\n                        if (row-1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[row-1][col] == \u0026#39;1\u0026#39;) {\n                            grid[row-1][col] = \u0026#39;0\u0026#39;;\n                            q.push({row-1,col});\n                        }\n                        if (col+1 \u0026lt; nc \u0026amp;\u0026amp; grid[row][col+1] == \u0026#39;1\u0026#39;) {\n                            grid[row][col+1] = \u0026#39;0\u0026#39;;\n                            q.push({row,col+1});\n                        }\n                        if (col-1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[row][col-1] == \u0026#39;1\u0026#39;) {\n                            grid[row][col-1] = \u0026#39;0\u0026#39;;\n                            q.push({row,col-1});\n                        }\n                        q.pop();\n                    }\n                }\n            }\n        }\n        return num;\n    }\n};\n```\n\n**总结**\n\n广搜的实现还是较为容易，第一次做时以为只需要向根节点右下方遍历就行了，结果遇到了特例：*工字形* 的岛屿等，如\n\n```\n111\n010\n111\n```\n\n若是只向右下方搜索就会得出岛屿为2。\n\n","date":"2020-06-28","description":"","objectID":"/200-number-of-islands/","tags":"广度优先搜索\n队列","title":"#200 岛屿数量","uri":"/200-number-of-islands/"},{"content":"\n使用HUGO+Github Pages搭建个人博客\n\n\u0026lt;!--more--\u0026gt;\n\n## 安装HUGO\n\n由于WSL2的LocalHost和主机不一样，导致没办法本地预览，我放弃了在WSL上安装hugo，而是安装在Windows上，然后通过WSL调用`hugo.exe`来完成工作流。\n\n在 [HUGO的github仓库](https://github.com/gohugoio/hugo/) 下载windows Release版本，由于下载的很慢，我使用github镜像 [link](https://github.wuyanzheshui.workers.dev/) 来下载然后把hugo.exe的路径添加到系统环境变量。终端里执行\n\n```bash\nhugo.exe version\n```\n\n打印版本信息，一切正常。\n\n## 配置\n```bash\nhugo new site /path/to/site\n```\n\n后，将建立一个文件夹，结构如下\n\n```\n.\n├── archetypes\n├── config.toml\n├── content\n├── data\n├── layouts\n├── resources\n├── static\n└── themes\n```\n\n首先要安装一个主题，我选择了`LoveIt`主题，[仓库地址](https://github.com/dillonzq/LoveIt/ )。\n\n```bash\ngit clone git@github.com:dillonzq/LoveIt.git themes/LoveIt\n```\n\n然后需要编辑`config.toml`，我直接把`/themes/LoveIt/exampleSite`里的给复制了过来，然后略加一点修改就行了。注释非常详尽，参照着改就行了。[link](https://hugoloveit.com/)的文档就更加详尽了，以后遇到坑再看吧。\n\n`static`用来放图片，`aechetypes`里的`default.md`在每次创建文章的时候自动加一个模板。\n\n## 发布内容\n\n```bash\nhugo new posts/post.md\n```\n确认要发布后，然后把`draft:true` 改为`false`\n\n然后\n\n```bash\nhugo server\n```\n\n就可以在1313端口预览网页了。\n\n## 部署到Github Pages\n\n1. 创建github仓库，名字为`UserName.github.io`\n2. 进入`public`文件夹，执行`git init`，`git remote add xxx`\n3. 将`public`文件夹内容`push`到github\n\n","date":"2020-06-24","description":"","objectID":"/hugo-go/","tags":"HUGO","title":"HUGO搭建博客","uri":"/hugo-go/"},{"content":"\n\u0026gt; 西安交通大学能源与动力工程本科在读\n\n","date":"2019-08-02","description":"","objectID":"/about/","tags":"","title":"关于 Fr13ndSDP","uri":"/about/"}]