[{"content":"\nSome crap about turbulence and LES\n\n\u0026lt;!--more--\u0026gt;\n\n\u0026gt; Versteeg, H. K. and W. Malalasekera (2007). An introduction to computational fluid dynamics: the finite volume method, Pearson education.\n\n雷诺数$Re$代表了流体中惯性力（与对流效应相关）和粘性力之间的比值。实验观察到，在某一临界雷诺数 ${Re}_{crit}$ 之下，流动是平稳的，流体的层与层间是有序的滑移。如果边界条件不随时间发生改变，流动是稳态的，此时称为**层流**。\n\n当雷诺数高于${Re}_{crit}$值时，就会发生一系列复杂的事件，最终导致流动特性的根本变化。 在最终状态下，流动行为是随机且混乱的。 即使在恒定施加的边界条件下，运动本质上也变得不稳定。 速度和所有其他流动特性以随机和混乱的方式变化，此时流动称为**湍流**。\n\n即使在速度和压力脉动仅存一维或者二维空间的流动中，湍流带来的扰动总是具有三维的空间特征。此外，湍流中往往还存在着涡，这些涡的尺度范围非常广，最大的涡通过称为**涡伸展**（vortex stretching）的过程与主流相互作用并从中提取能量。 剪切流中平均速度梯度的存在使旋转的涡变形，从而使得适当的涡被拉伸，因为它一端被迫比另一端移动得快。\n\n最大的涡的特征速度$\\vartheta$和特征长度$\\ell$具有与主流速度和长度相当的量级，可以定义一个“大涡”雷诺数${Re}_{\\ell}=\\vartheta\\ell/\\nu$，这个数值很大并将接近主流雷诺数，表明大涡中起主导作用的是惯性力，粘性力基本可以忽略。因此，这些大涡具有良好的无粘性，并且在涡伸展过程中其动量守恒，在主流做功作用下，其速度增大，截面积减小。小一些的涡虽然也受到主流影响，但较大程度上受到大涡的影响，因此能量从大涡一级级地传送到最小的涡上，这被称为**能量级联**（energy cascade）。湍流蕴含的能量也因此包含很宽的频率（$f$）或波数（$\\kappa=2\\pi f/U$）范围。湍流能谱如下图\n\n{{\u0026lt; figure src=\u0026#34;/images/Ferziger-on-LES/spectrum.png\u0026#34; title=\u0026#34;spectrum\u0026#34;\u0026gt;}}\n\n图中，谱能量$E(\\kappa)$是波数的函数，单位$m^3/s^2$，它代表单位质量，单位波数的扰动动能。图中显示了最大的涡具有最大的动能，随着波数增大$E(\\kappa)$迅速减小，因此最小的涡具有最低的能量。\n\n湍流中最小尺寸的运动大概是0.1到0.01mm的量级，频率10kHz，最小涡的雷诺数$R e_{\\eta}=v \\eta / \\nu=1$。\n\n\u0026gt; Ferziger, J. H., et al. (2020). Computational methods for fluid dynamics, Springer.\n\n## 1. 大涡模拟方程\n\n湍流具有很宽的空间和时间尺度；在流体中的涡的尺度如左图所示，右图展示了一个典型的在流场中一点处速度分量的历史演变，这其中扰动的尺度是很明显的。\n\n{{\u0026lt; figure src=\u0026#34;/images/Ferziger-on-LES/vortex.png\u0026#34; title=\u0026#34;vortex\u0026#34;\u0026gt;}}\n\n大尺度的涡往往比小尺度的涡具有更大的能量；它们的大小和强度使得它们称为流场中守恒变量最强有力的传播者，而小的涡则更弱，并对守恒变量提供更小的输运作用。因此大涡模拟的基本思路就是对这些影响更大的大涡进行更精确的模拟。LES已经成为大气科学的主要工具，用于研究云层、降水、污染物质运输和山谷中的气流。在地球大气边界层中，LES所处理的物理过程包括浮力、旋转、夹带、凝结以及与粗糙地面和海洋表面的相互作用。LES甚至也被用于设计高压燃气透平并且在空气声学模拟中占据主导地位。\n\n要定义需要精确计算的量很重要。我们需要一个仅包含大尺度涡的速度场，而这个速度场最好是由原速度场滤波而得来的。在这种方法中，大的或被分辨率的场，即被模拟的场，本质上是完整的场的局部平均值。我们将使用一维符号;把它推广到三维是很简单的。滤波后速度定义为\n$$\n\\bar{u}_i(x) = \\int G(x,x^{\u0026#39;})u_i(x^{\u0026#39;})dx^{\u0026#39;}\n$$\n其中$G(x,x^{\u0026#39;})$为滤波器核函数，这是一个局部函数。在LES中应用的核函数包括一个高斯滤波器，一个盒式滤波器（box filter）和一个截止滤波器（将波数在截止值之上的所有傅里叶系数消除掉）。每一个滤波器都有一个与之对应的长度单位$\\Delta$。一般认为尺度大于$\\Delta$的涡是大涡，小于$\\Delta$的是小涡，对这些小涡的计算需要引入模型。\n\n当对不可压缩流的N-S方程加以滤波，就会得到一组与URANS（unsteady RANS）方程组相似的方程：\n$$\n\\frac{\\partial \\rho\\bar{u}_i}{\\partial t}+\\frac{\\partial(\\rho \\overline{u_i u_j})}{\\partial x_j}=-\\frac{\\partial \\bar{p}}{\\partial x_i}+\\frac{\\partial}{\\partial x_j}\\left[\\mu(\\frac{\\partial \\bar{u}_i}{\\partial x_j}+\\frac{\\partial \\bar{u}_j}{\\partial x_i})\\right]\n$$\n\n由于连续性方程是线性的，滤波后不改变：\n$$\n\\frac{\\partial(\\rho \\bar{u}_i)}{\\partial x_i} = 0\n$$\n\n由于很重要的一点：\n$$\n\\overline{u_iu_j}\\neq \\bar{u}_i\\bar{u}_j\n$$\n\n而该不等式左侧难以计算，因此在近似计算时由该不等式引起的误差表示为\n$$\n\\tau^s_{ij} = -\\rho(\\overline{u_iu_j}-\\bar{u}_{i}\\bar{u}_{j}\n$$\n因此LES计算中的动量方程为\n$$\n\\frac{\\partial \\rho\\bar{u}_i}{\\partial t}+\\frac{\\partial(\\rho \\bar{u}_i\\bar{u}_j)}{\\partial x_j}=\\frac{\\partial \\tau^s_{ij}}{\\partial x_j}-\\frac{\\partial \\bar{p}}{\\partial x_i}+\\frac{\\partial}{\\partial x_j}\\left[\\mu(\\frac{\\partial \\bar{u}_i}{\\partial x_j}+\\frac{\\partial \\bar{u}_j}{\\partial x_i})\\right]\n$$\n在LES中，$\\tau^s_{ij}$被称为亚网格尺度雷诺应力（subgrid-scale Reynolds stress）。“应力”源自于对于这一项的处理方式而非物理本质，它实际上是由小尺度或未解析尺度的作用所引起的大尺度动量通量。“亚网格尺度”这个名字也具有误导性，因为滤波窗口宽度，$\\Delta$，除了明显需要满足的条件$\\Delta \\geq h$外不必与网格大小$h$有关。当今，用来描述亚网格尺度雷诺应力的模型分为subgrid-scale(SGS)和subfilter-scale(SFS)模型。\n\n亚网格尺度雷诺应力包含小尺度场的局部平均值，因此它的模型应该基于局部速度场，或者可能基于局部流体运动的历史。后者可以通过求解偏微分方程模型来实现，从而获得确定亚网格尺度雷诺应力所需的参数。\n\n## 2. 滤波[^3] \n\n滤波，一种平均化操作。在DNS中，速度场$\\boldsymbol U(\\vec{x},t)$需要在非常细密的网格上（直到Kolmogorov 尺度$\\eta$）被解析，在LES中，则需要对速度场进行低通滤波，使得滤波后的速度场$\\overline{\\boldsymbol U}{(\\vec{x},t)}$在较粗的网格上得以被解析。\n\n滤波操作表示为\n$$\n\\overline{\\boldsymbol U}{(\\vec{x},t)} = \\int_{\\Omega}G(\\vec{r}, t)\\boldsymbol{U}(\\vec{x}-\\vec{r},t)d\\vec{r}\n$$\n其中$\\Omega$表示整个流域，滤波函数满足归一化条件\n$$\n\\int_{\\Omega}G(\\vec{r},\\vec{x})d\\vec{r} = 1\n$$\n在最简单的情况下，滤波函数是各向均匀的，即和$\\vec{x}$无关。\n\n假设$U(x)$为定义在$-\\infty \u0026lt; x \u0026lt; \\infty$ 上的标量函数，暂且称之为速度场，很容易可以将其扩展到三维。使用各项均匀滤波函数$G(r)$，滤波后的速度场为\n$$\n\\overline{U}(x) = \\int_{-\\infty}^{\\infty}G(r)U(x-r)dr\n$$\n\n以盒式滤波器（Box Filter）为例，$\\overline{U}(x)$就是在$x-1/2\\Delta \u0026lt; x^{\\prime} \u0026lt; x+1/2\\Delta$上对于$U(x^\\prime)$进行平均得到的。高斯滤波函数选取为\n$$\nG(r) = \\sqrt{\\frac{6}{\\pi \\Delta^2}} exp({-\\frac{6r^2}{\\Delta^2}})\n$$\n即均值为0，方差为$\\sigma^2 = 1/12\\Delta^2$的高斯分布。$\\sigma^2$的选取是根据其二阶矩$\\int_{-\\infty}^{\\infty}r^2G(r)dr = 1/12\\Delta^2$，保持与盒式滤波器一致而确定的。\n\n```matlab\n% 功能：对一维信号的高斯滤波，头尾r/2的信号不进行滤波\n% r     :高斯滤波模板数（关联点数）\n% sigma :标准差\n% y     :需要进行高斯滤波的序列\n% grid_scale: 网格分辨率\n% delta :滤波尺度\ngrid_scale = 0.5;\nx = 1:grid_scale:50;\ny = x + rand(1,length(x))*10;\n\ndelta = 3; \nr        = 5; \nsigma    = sqrt(delta^2/12);\ny_filted = Gaussianfilter(r, sigma, y);\nfluc = y - y_filted;\n% 作图对比\nplot(x, y, x, y_filted, x, fluc);\ntitle(\u0026#39;高斯滤波\u0026#39;);\nlegend(\u0026#39;滤波前\u0026#39;,\u0026#39;滤波后\u0026#39;,\u0026#39;扰动\u0026#39;)\n\nfunction y_filted = Gaussianfilter(r, sigma, y)\n\n% 生成一维高斯滤波模板\nGaussTemp = ones(1,r*2-1);\nfor i=1 : r*2-1\n    GaussTemp(i) = exp(-(i-r)^2/(2*sigma^2))/(sigma*sqrt(2*pi));\nend\n\n% 高斯滤波\ny_filted = y;\nfor i = r : length(y)-r+1\n    y_filted(i) = y(i-r+1 : i+r-1)*GaussTemp\u0026#39;;\nend\nend\n```\n\n{{\u0026lt; figure src=\u0026#34;/images/","date":"2020-12-14","description":"","objectID":"/2020/ferziger-on-les/","tags":"LES,湍流","title":"Ferziger and Blazek on LES","uri":"/2020/ferziger-on-les/"},{"content":"\n伴随优化基本方程的推导以及OpenFOAM中的实现\n\n\u0026lt;!--more--\u0026gt;\n\n\u0026gt; 使用如下的符号记法：全导数 $d_x$ $(\\nabla_x)$，偏导 $\\partial_x$，微分 $d$.\n\n## 1 伴随方法\n\n在一个偏微分方程系统中，假设存在变量 $x\\in R^{n_x}, p\\in R^{n_p}$，方程 $f(x,p):R^{n_x}\\times R^{n_p}\\rightarrow R$以及关系 $g(x,p) = 0$，且 $g_x$ 处处非奇异，$d_pf$怎么求？\n\n### 1.1 动机\n\n$g(x,p)=0$ 的求解是CFD求解器的核心，给定参数 $p$，程序将计算出 $x$。例如 $p$ 可以是边界条件或初始条件的参数，也可以是物性参数，而 $x$ 是计算得到的场量，这种求解模式是*正问题*。如果引入 $f(x,p)$作为度量标准，例如用来计算 $x$ 的光滑程度，那么通常需要最小化$f$，这种求解模式是*反问题*。\n\n梯度 $d_pf$ 很有用，可以用来计算优化问题 $min_pf$ 中 $f$ 对于参数 $p$ 变化的敏感程度，并使用梯度下降方法求解最优化问题。\n\n### 1.2 推导\n\n1）\n\n考虑一个简单的函数 $f(x)$，首先由链式法则有\n$$\nd_pf = d_df(x(p)) = \\partial_xfd_px\\ (=f_xx_p)\n$$\n其次因为 $g(x,p) = 0$ 处处成立，则 $d_pg = 0$， 也就是\n$$\ng_xx_p + g_p = 0\n$$\n那么得到\n$$\nd_pf = -f_xg_x^{-1}g_p\n$$\n从线性代数的观点看，$f_xg_x^{-1}$ 是一个行向量乘以 $n_x\\times n_x$ 的矩阵，并且是以下方程的解\n$$\ng_x^{T}\\lambda = -f_x^{T}\n$$\n称为伴随方程，$\\lambda$称为伴随变量。得到 $d_pf = \\lambda^Tg_p$\n\n2）\n\n定义拉格朗日函数\n$$\nL(x,p,\\lambda) = f(x) + \\lambda^Tg(x,p)\n$$\n这里$\\lambda$是拉格朗日乘子组成的向量，由于 $g(x,p)$ 处处为零，$\\lambda$可以随意选取。\n$$\nd_pf(x) = d_pL = f_xx_p + d_p\\lambda^Tg + \\lambda^T(g_xx_p+g_p)\\\\\\\\ =(f_x+\\lambda^Tg_x)x_p+\\lambda^Tg_p\n$$\n如果选取 $g^T\\lambda = -f_x^T$，第一项为零，可以避免计算 $x_p$ 并且得到 $d_pf = \\lambda^Tg_p$，与第一种推导方式相同。\n\n或者，由于$df = f_xdx +f_pdp = (f_x+\\lambda^Tg_x )dx+ \\lambda^Tg_pdp$，可以推至同样的结果。\n\n## 2 PDE约束的连续伴随问题\n\n### 2.1 一般伴随方程\n\n给出一个特定的优化问题\n$$\nmin\\quad J = J(\\mathbf{v}, p, \\alpha)\\\\\\\\ s.t.\\quad R(\\mathbf{v},p,\\alpha) = 0\n$$\n考虑由连续介质力学给出的约束，$\\mathbf{v}$ 与 $p$ 作为变量，即等价为前文中的 $x$; $\\alpha$ 作为 设计参数，即等价于前文中的$p$，给出问题\n$$\nmin\\quad J = J(\\mathbf{v},p,\\alpha)\\\\\\\\ s.t. \\quad R^{u} = \\nabla\\cdot(\\mathbf{vv}) + \\nabla p - \\nabla\\cdot(2\\nu D(\\mathbf{v}))+\\alpha \\mathbf{v} = 0\\\\\\\\ R^{p} = \\nabla \\cdot \\mathbf{v} = 0\n$$\n上式由达西定律引入了渗透率作为源项，假设某一区域使得目标函数增大，可以通过减小这一区域的渗透率作为惩罚。$D(\\mathbf{v})=\\frac{1}{2}(\\nabla \\mathbf{v}+\\nabla \\mathbf{v}^T)$ 代表应变率张量。\n\n使用拉格朗日乘数法将其转变为无约束优化问题\n$$\nmin \\quad L = J+\\int_\\Omega(\\mathbf{u},q)Rd\\Omega\\\\\\\\ = J+ \\int_{\\Omega}qR^pd\\Omega + \\int_\\Omega{\\mathbf{u}\\cdot R^{u}}d\\Omega\n$$\n其中$(\\mathbf{u},q)$为拉格朗日乘子，称其为伴随速度和伴随压力（后面会看到为什么），但是实际上并没有物理含义。\n\n因为变分\n$$\n\\delta L = \\delta_{\\alpha}L+ \\delta_{\\mathbf{v}}L+\\delta_{p}L\n$$\n注意这里没有将粘度作为微分变量，是一种近似的做法，被称为“冻结湍流”。\n\n由于 $(\\mathbf{u},q)$可以自由选取，取 适当的值使得 $\\delta_{\\mathbf{v}}L+\\delta_pL = 0$ 成立，便得到\n$$\n\\delta_{\\alpha}L = \\delta_{\\alpha}J + \\int_{\\Omega}\\mathbf{u}\\cdot \\mathbf{v}d\\Omega\n$$\n当考虑网格中的目标函数关于 $\\alpha$的梯度，可以得到\n$$\n\\frac{\\partial L}{\\partial \\alpha_i} =  \\frac{\\partial J}{\\partial\\alpha_i} + \\mathbf{u_i}\\cdot \\mathbf{v_i}V_i\n$$\n其中 $V_i$ 为网格体积。\n\n如果 $\\delta_{\\mathbf{v}}L+\\delta_pL = 0$ 成立，那么伴随方程\n$$\n\\delta_{\\mathbf{v}}J + \\delta_{p}J +\n\\int_{\\Omega}\\mathbf{u}\\cdot [\\nabla\\cdot(\\mathbf{v\\delta v})+\\nabla\\cdot(\\mathbf{\\delta v v})   - \\nabla\\cdot(2\\nu D(\\delta\\mathbf{v}))+\\alpha \\delta \\mathbf{v}]d\\Omega \\\\\\\\ - \\int_{\\Omega}q\\nabla \\cdot \\delta \\mathbf{v}d\\Omega + \\int_{\\Omega}\\mathbf{u}\\cdot \\nabla \\delta pd\\Omega = 0\n$$\n积分使用散度公式与高斯散度定理(以及一些张量运算的推导)：\n$$\n\\nabla\\cdot (q\\mathbf{v}) = \\nabla q \\cdot \\mathbf{v}+q\\nabla \\cdot \\mathbf{v}\\\\\\\\ \\int_{\\Omega}\\nabla \\cdot (q\\mathbf{v})\\ d\\Omega =\\int_{\\Gamma}q\\mathbf{ v}\\cdot \\mathbf{n}d\\Gamma\n$$\n并且把 $J$ 拆分为 \n$$\nJ = \\int_{\\Gamma}J_{\\Gamma}\\ d\\Gamma + \\int_{\\Omega} J_{\\Omega}\\ d\\Omega\n$$\n得到  (*注意*  $(\\mathbf{v}\\cdot \\nabla)\\mathbf{u}=\\nabla(\\mathbf{vu})$）\n$$\n\\int_{\\Gamma} \\mathrm{d} \\Gamma\\left(\\mathbf{u} \\cdot \\mathbf{n}+\\frac{\\partial J_{\\Gamma}}{\\partial p}\\right) \\delta p+\\int_{\\Omega} \\mathrm{d} \\Omega\\left(-\\nabla \\cdot \\mathbf{u}+\\frac{\\partial J_{\\Omega}}{\\partial p}\\right) \\delta p\\\\\\\\ \\quad+\\int_{\\Gamma} \\mathrm{d} \\Gamma\\left(\\mathbf{n}(\\mathbf{u} \\cdot \\mathbf{v})+\\mathbf{u}(\\mathbf{v} \\cdot \\mathbf{n})+2 v \\mathbf{n} \\cdot \\mathbf{D}(\\mathbf{u})-q \\mathbf{n}+\\frac{\\partial J_{\\Gamma}}{\\partial \\mathbf{v}}\\right) \\cdot \\delta \\mathbf{v}-\\int_{\\Gamma} \\mathrm{d} \\Gamma 2 v \\mathbf{n} \\cdot \\mathbf{D}(\\delta \\mathbf{v}) \\cdot \\mathbf{u}\\\\\\\\ \\quad+\\int_{\\Omega} \\mathrm{d} \\Omega\\left(-\\nabla \\mathbf{u} \\cdot \\mathbf{v}-(\\mathbf{v} \\cdot \\nabla) \\mathbf{u}-\\nabla \\cdot(2 v \\mathbf{D}(\\mathbf{u}))+\\alpha \\mathbf{u}+\\nabla q+\\frac{\\partial J_{\\Omega}}{\\partial \\mathbf{v}}\\right) \\cdot \\delta \\mathbf{v}=0\n$$\n\n观察上面的式子，他应该对任意的 $\\delta \\mathrm{p}$和 $\\delta \\mathbf{v}$ 成立，因此各个积分分别等于0，当在 $\\Omega$ 内积分时，边界积分为零，因此得到 $\\Omega$ 内的伴随方程\n$$\n-\\nabla (\\mathbf{vu})-\\nabla \\mathbf{u}\\cdot \\mathbf{v} = -\\nabla{q}+\\nabla \\cdot (2\\nu D(\\mathbf{u}))-\\alpha \\mathbf{u} - \\frac{\\partial J_{\\Omega}}{\\partial \\mathbf{v}}\\\\\\\\ \\nabla \\cdot \\mathbf{u} = \\frac{\\partial J_{\\Omega}}{\\partial p}\n$$\n可以看到，这组方程与 N-S 方程非常相似，因此变量 $(\\mathbf{u}, q)$ 被看作是非物理的速度和压力。\n\n### 2.2 边界条件\n\n在边界处，可以得到边界条件为\n$$\n\\int_{\\Gamma} \\mathrm{d} \\Gamma\\left(\\mathbf{n}(\\mathbf{u} \\cdot \\mathbf{v})+\\mathbf{u}(\\mathbf{v} \\cdot \\mathbf{n})+2 v \\mathbf{n} \\cdot \\mathbf{D}(\\mathbf{u})-q \\mathbf{n}+\\frac{\\partial J_{\\Gamma}}{\\partial \\mathbf{v}}\\right) \\cdot \\delta \\mathbf{v}-\\int_{\\Gamma} \\mathrm{d} \\Gamma 2 v \\mathbf{n} \\cdot \\mathbf{D}(\\delta \\mathbf{v}) \\cdot \\mathbf{u}=0\\\\\\\\ \\int_{\\Gamma} \\mathrm{d} \\Gamma\\left(\\mathbf{u} \\cdot \\mathbf{n}+\\frac{\\partial J_{\\Gamma}}{\\pa","date":"2020-12-03","description":"","objectID":"/2020/adjoint-optimization/","tags":"Adjoint Method","title":"Adjoint Optimization","uri":"/2020/adjoint-optimization/"},{"content":"\n关于代码优化的一些启示\n\n\u0026lt;!--more--\u0026gt;\n\n今天看到一篇博文[Optimize Your Code: Matrix Multiplication](https://docs.microsoft.com/zh-cn/archive/blogs/xiangfan/optimize-your-code-matrix-multiplication)，里面提出了几个对于矩阵乘法的优化方法，于是试了一下。\n\n## 优化方法\n\n**1. 原始写法**\n\n```c++\ntemplate\u0026lt;typename T\u0026gt;\nvoid matrixMul1(int size, T** m1, T** m2, T** result) {\n    for (int i=0; i\u0026lt;size; i++) {\n        for (int j=0; j\u0026lt;size; j++) {\n            result[i][j] = 0;\n            for (int k=0; k\u0026lt;size; k++) {\n                result[i][j] += m1[i][k] *m2[k][j];\n            }\n        }\n    }\n}\n```\n\n**2. 采用临时变量**\n\n```c++\ntemplate\u0026lt;typename T\u0026gt;\nvoid matrixMul2(int size, T** m1, T** m2, T** result) {\n    for (int i=0; i\u0026lt;size; i++) {\n        for (int j=0; j\u0026lt;size; j++) {\n            T c = 0;\n            for (int k=0; k\u0026lt;size; k++) {\n                c += m1[i][k] *m2[k][j];\n            }\n            result[i][j] = c;\n        }\n    }\n}\n```\n\n很简单，但确实很有效。采用临时变量节省了在`result`中寻址并写入值的时间\n\n**3. 连续寻址**\n\n```c++\ntemplate\u0026lt;typename T\u0026gt;\nvoid transpose(int size, T** m) {\n    for (int i = 0; i \u0026lt; size; i++) {\n        for (int j = i+1; j \u0026lt; size; j++) {\n            swap(m[i][j],m[j][i]);\n        }\n    }\n}\n\ntemplate\u0026lt;typename T\u0026gt;\nvoid matrixMul3(int size, T** m1, T** m2, T** result) {\n    transpose(size, m2);\n    for (int i=0; i\u0026lt;size; i++) {\n        for (int j=0; j\u0026lt;size; j++) {\n            T c = 0;\n            for (int k=0; k\u0026lt;size; k++) {\n                c += m1[i][k] *m2[j][k];\n            }\n            result[i][j] = c;\n        }\n    }\n    transpose(size, m2);\n}\n```\n\n转置矩阵，使`m1[i]`和`m2[i]`都可以按顺序访问，这会极大提高性能。\n\n## 开启优化对于性能的影响\n\n采用下面的测试代码，比较上面的三种方案计算速度，并和Eigen库做对比。\n\n```c++\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;ctime\u0026gt;\n#include \u0026lt;Eigen/Dense\u0026gt;\nusing namespace Eigen;\nusing namespace std;\n\nclock_t start_t,end_t;\n\ntemplate\u0026lt;typename T\u0026gt;\nT** randomMatrix(int size) {\n    T** a;\n    a = new T* [size];\n    for (int i=0; i\u0026lt;size; i++) {\n        a[i] = new T [size];\n    }\n    for (int i=0; i\u0026lt;size; i++) {\n        for (int j=0; j\u0026lt;size; j++) {\n            a[i][j] = (T)(1.0 - rand()/(RAND_MAX/2.0));\n        }\n    }\n    return a;\n}\n\ntemplate\u0026lt;typename T\u0026gt;\nvoid matrixMul1(int size, T** m1, T** m2, T** result) {\n    for (int i=0; i\u0026lt;size; i++) {\n        for (int j=0; j\u0026lt;size; j++) {\n            result[i][j] = 0;\n            for (int k=0; k\u0026lt;size; k++) {\n                result[i][j] += m1[i][k] *m2[k][j];\n            }\n        }\n    }\n}\n\ntemplate\u0026lt;typename T\u0026gt;\nvoid matrixMul2(int size, T** m1, T** m2, T** result) {\n    for (int i=0; i\u0026lt;size; i++) {\n        for (int j=0; j\u0026lt;size; j++) {\n            T c = 0;\n            for (int k=0; k\u0026lt;size; k++) {\n                c += m1[i][k] *m2[k][j];\n            }\n            result[i][j] = c;\n        }\n    }\n}\n\n\ntemplate\u0026lt;typename T\u0026gt;\nvoid transpose(int size, T** m) {\n    for (int i = 0; i \u0026lt; size; i++) {\n        for (int j = i+1; j \u0026lt; size; j++) {\n            swap(m[i][j],m[j][i]);\n        }\n    }\n}\n\ntemplate\u0026lt;typename T\u0026gt;\nvoid matrixMul3(int size, T** m1, T** m2, T** result) {\n    transpose(size, m2);\n    for (int i=0; i\u0026lt;size; i++) {\n        for (int j=0; j\u0026lt;size; j++) {\n            T c = 0;\n            for (int k=0; k\u0026lt;size; k++) {\n                c += m1[i][k] *m2[j][k];\n            }\n            result[i][j] = c;\n        }\n    }\n    transpose(size, m2);\n}\n\n\nint main(int argc, char *argv[]) {\n    int n = atoi(argv[1]);\n\n    double** m1 = randomMatrix\u0026lt;double\u0026gt;(n);\n    double** m2 = randomMatrix\u0026lt;double\u0026gt;(n);\n    double** m3 = randomMatrix\u0026lt;double\u0026gt;(n);\n\n    double endTime = 0;\n    for (int i=0; i\u0026lt;10; i++) {\n        start_t = clock();\n        matrixMul1(n,m1,m2,m3);\n        end_t = clock();\n        endTime += (double)(end_t-start_t)/CLOCKS_PER_SEC;\n    }\n    cout \u0026lt;\u0026lt; endTime*100 \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl;\n\n    endTime = 0;\n    for (int i=0; i\u0026lt;10; i++) {\n        start_t = clock();\n        matrixMul2(n,m1,m2,m3);\n        end_t = clock();\n        endTime += (double)(end_t-start_t)/CLOCKS_PER_SEC;\n    }\n    cout \u0026lt;\u0026lt; endTime*100 \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl;\n\n    endTime = 0;\n    for (int i=0; i\u0026lt;10; i++) {\n        start_t = clock();\n        matrixMul3(n,m1,m2,m3);\n        end_t = clock();\n        endTime += (double)(end_t-start_t)/CLOCKS_PER_SEC;\n    }\n    cout \u0026lt;\u0026lt; endTime*100 \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl;\n\n    MatrixXd em1 = MatrixXd::Random(n,n);\n    MatrixXd em2 = MatrixXd::Random(n,n);\n    MatrixXd em3 = MatrixXd::Random(n,n);\n\n    endTime = 0;\n    for (int i=0; i\u0026lt;10; i++) {\n        start_t = clock();\n        em3 = em1*em2;\n        end_t = clock();\n        endTime += (double)(end_t-start_t)/CLOCKS_PER_SEC;\n    }\n    cout \u0026lt;\u0026lt; endTime*100 \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl;\n\n    return 0;\n}\n```\n\n对两个nxn的随机方阵做相乘运算，随机数范围-1~1，双精度，取十次计算的平均耗时。得到如下结果\n\n| size = 500x500 | 无编译优化   | -O1         | -O2          | -O3         |\n| -------------- | ------------ | ----------- | ------------ |","date":"2020-11-08","description":"","objectID":"/2020/optimize-code/","tags":"优化代码","title":"Optimize Code","uri":"/2020/optimize-code/"},{"content":"\n复习一下线性代数\n\n\u0026lt;!--more--\u0026gt;\n\n## 背景\n\n当在非结构网格上离散对流项时，利用高斯散度定理可以得到\n$$\n\\int_{CV}\\nabla \\cdot (\\rho \\phi \\mathbf{u})dV = \\sum_{all\\ surfaces}\\int_{\\Delta A_i}\\mathbf{n_i}\\cdot (\\rho \\phi \\mathbf{u})dA\n$$\n定义一个对流通量$F_i$\n$$\nF_i = \\int_{\\Delta A_i}\\mathbf{n_i}\\cdot (\\rho \\mathbf{u})dA \\simeq \\mathbf{n_i}\\cdot(\\rho \\mathbf{u})\\Delta A_i\n$$\n\n\n当使用交错网格，此时界面上的速度矢量是已知的，上式可以直接计算出来。当使用同位网格，则需要界面上的插值技术如**Rhie-Chow插值**[^1]来避免棋盘型压力分布。\n\n对流项可以表示为\n$$\n\\sum_{all\\ surfaces}F_i \\phi_i\n$$\n$\\phi_i$是界面上的物理量，需要满足守恒性、有界性和有向性。在非结构网格上使用一阶迎风差分是不可能的，结构网格下的一阶迎风格式在流向不与坐标轴平行时会引起假扩散。这在连正交都不能保证的非结构网格中将引入很强的假扩散，如果采用线性迎风差分或者是TVD格式，就必须要计算$\\phi$的梯度（Darwish and Moukalled, 2003）。\n\n一种可行的方法是**最小二乘梯度重建**（least-squares gradient reconstruction），参照下图：\n\n{{\u0026lt; figure src=\u0026#34;/images/The-QR-Factorization/grid.png\u0026#34; title=\u0026#34;一个非结构网格\u0026#34;\u0026gt;}}\n\n$$\n\\phi_i - \\phi_0 \\simeq \\left(\\frac{\\partial \\phi}{\\partial x}\\right)\\bigg|_0\\Delta x_i + \\left(\\frac{\\partial \\phi}{\\partial y}\\right)\\bigg|_0\\Delta y_i\n$$\n这组成了一个超定方程，用矩阵表示为\n\n$$\n\\begin{bmatrix} \\Delta x_{1} \u0026amp; \\Delta y_{1} \\\\\\\\ \\Delta x_{2} \u0026amp; \\Delta y_{2} \\\\\\\\ \\Delta x_{3} \u0026amp; \\Delta y_{3} \\\\\\\\ \\vdots \u0026amp; \\vdots \\\\\\\\ \\Delta x_{N} \u0026amp; \\Delta y_{N} \\end{bmatrix}\n\\begin{bmatrix} \\frac{\\partial \\phi}{\\partial x}\\big|_0 \\\\\\\\ \\frac{\\partial \\phi}{\\partial y}\\big|_0 \\end{bmatrix} \\simeq\n\\begin{bmatrix} \\phi_{1}-\\phi_{0} \\\\\\\\ \\phi_{2}-\\phi_{0} \\\\\\\\ \\phi_{3}-\\phi_{0} \\\\\\\\ \\vdots \\\\\\\\ \\phi_{N}-\\phi_{0} \\end{bmatrix}\n$$\n\n那么两个方向上的梯度应该取多少使得误差最小呢，也就是求 \n\n$$\n\\mathop{min} \\limits_{x}||\\boldsymbol{Ax-b||^2}\n$$\n\n 这其实是一个线性最小二乘问题，也就是这个方法名字的由来。一种解法是 $\\boldsymbol{x = (A^{T}A)^{-1}A^TB}$，然而这可能导致精度上的重大缺陷，首先，矩阵求逆的精度较低，计算量较大，其次，也是更重要的原因：从**条件数**[^2]判断，$\\boldsymbol{A^TA}$的条件数是$\\boldsymbol{A}$条件数的平方。这种做法会使得方程比原来的超定方程更加病态（badly conditioned），在有限的浮点数精度下，矩阵$\\boldsymbol{A^TA}$可能是奇异的，求逆就无法进行。\n\n## QR分解\n\n{{\u0026lt; figure src=\u0026#34;/images/The-QR-Factorization/qr.png\u0026#34; title=\u0026#34;QR分解两种形式\u0026#34;\u0026gt;}}\n\n对$\\boldsymbol{A}$进行QR分解$\\boldsymbol{A = QR}$，$\\boldsymbol{Q}$是正交矩阵，满足$\\boldsymbol{Q^TQ =I}$，$\\boldsymbol{R}$为上三角矩阵。\n\n那么 $\\boldsymbol{x = R^{-1}Q^Tb}$，而上三角矩阵的求逆很简单。\n\n现在问题是，如何进行分解呢？\n\n### 1. Gram-Schmidt正交化方法\n\n矩阵$\\boldsymbol{A}$表示为$\\boldsymbol{A} = \\boldsymbol{[v_1, v_2,...,v_n]}$，将这些基底向量正交化：\n$$\n\\boldsymbol{\\beta_1 = v_1}\\\\\\\\ \\boldsymbol{\\beta_2=v_2-\\langle v_2,\\eta_1\\rangle \\eta_1}\\\\\\\\ \\vdots\\\\\\ \\boldsymbol{\\beta_n=v_n-\\sum_{i=1}^{n-1}\\langle v_n, \\eta_i\\rangle \\eta_i}\n$$\n\n其中的$\\boldsymbol{\\eta_n = \\frac{\\beta_n}{||\\beta_n||}}$即标准正交基。那么有\n{{\u0026lt; figure src=\u0026#34;/images/The-QR-Factorization/matrix.png\u0026#34;\u0026gt;}}\n显然，$\\boldsymbol{\\eta_i}$组成了正交矩阵，又由$\\boldsymbol{||\\beta_i||}\\neq 0$，$\\boldsymbol{R}$是一个主对角元非零的上三角矩阵。\n\n### 2. Householder变换\n\n\u0026gt; 相比与Gram-Schmidt正交化，使用Householder变换具有更好的[数值稳定性](https://zh.wikipedia.org/wiki/数值稳定性)\n\nHouseholder变换是将一个向量关于某个$n-1$维子空间进行反射的操作。首先说明是如何进行反射的（暂时不考虑复矩阵）\n\n#### 2.1 怎么旋转\n\nHouseholder变换矩阵$\\boldsymbol{H} = \\boldsymbol{I} - \\boldsymbol{2vv^T}$，这个变换具有性质$\\boldsymbol{H^T = H, H^{-1} = H^T}$，即是对称正交的。其中$\\boldsymbol{v}$是平行于“镜面”的单位向量，那么\n$$\n\\boldsymbol{Hx = x-2v\\langle v,x\\rangle}\n$$\n\n{{\u0026lt; figure src=\u0026#34;/images/The-QR-Factorization/householder.png\u0026#34; title=\u0026#34;Householder反射变换\u0026#34;\u0026gt;}}\n\n很清楚，Householder就是一个反射变换。\n\n#### 2.2 怎么应用\n\n为了将他用在QR分解上，就得考虑如何将这个变换作用在矩阵$\\boldsymbol{A}$上从而得到$\\boldsymbol{Q}$，也就是说通过变换将部分基向量映射到一组维度递减的单位向量$\\boldsymbol{e_1,e_2,...,e_n}$上，例如$\\boldsymbol{e_1 = [1,0,0]^T, e_2 = [1,0]^T}$，得到$\\boldsymbol{\\Eta A = R}$，$\\boldsymbol{\\Eta}$将会是一系列正交变换的组合，从而也是正交的，那么$\\boldsymbol{Q = \\Eta ^T}$。\n\n为了将一个向量$\\boldsymbol{x}$反射到$\\boldsymbol{e_1}$，可选取“镜面向量”\n\n$$\n\\boldsymbol{u = x-||x||e_1,\\ v = \\frac{u}{||u||}}\n$$\n\n接下来对$\\boldsymbol{A}$的部分基向量依次通过变换$\\boldsymbol{H_i}$反射到$\\boldsymbol{e_1, e_2，...，e_n}$，生成矩阵$\\boldsymbol{R}$:\n$$\n\\boldsymbol{H_n...H_2H_1A = R}\n$$\n注意到$\\boldsymbol{H_n}$比$\\boldsymbol{H_{n-1}}$维度小，可令\n$$\n\\boldsymbol{H_n} = \\begin{pmatrix}\\boldsymbol{I_{k}}\u0026amp; 0\\\\\\\\ 0\u0026amp; {\\mathop{H}\\limits^\\sim}_n \\end{pmatrix}\n$$\n其中${\\mathop{H}\\limits^\\sim}_n$是真正对余子式起变换作用的。\n\n\n\n因此$\\boldsymbol{Q = [H_n...H_2H_1]^T = H_1H_2...H_n}$。然而在实际的求解过程中，不需要求出$\\mathbf{Q}$，因为\n$$\n\\boldsymbol{H_n...H_2H_1A}x = \\boldsymbol{H_n...H_2H_1b}\\\\\\\\ \\implies \\boldsymbol{Rx = z}\n$$\n由于$\\boldsymbol{R}$是上三角矩阵，那么只需要对这个方程逐步回代就可以求解。\n\n### 3. 其它方法\n\nQR分解还有Givens旋转等其他方法，上述的方法还有分类如Full QR Factorization、Reduced QR Factorization等，实现算法更是有许多的技巧，误差和稳定性分析也是一门大学问。但是我不想再深究下去了。\n\n## Practice\n```python\nimport numpy as np\n\ndef householder(A,b):\n    r = A.shape[0]\n    c = A.shape[1]\n    Q = np.identity(r)\n    R = np.copy(A)\n    z = np.copy(b)\n    for cnt in range(r - 1):\n        x = R[cnt:, cnt]\n        e = np.zeros_like(x)\n        e[0] = np.linalg.norm(x)\n        u = x - e \n        v = u / np.linalg.norm(u) # normalized \u0026#34;mirror vector\u0026#34;\n        Q_cnt = np.identity(r)\n        Q_cnt[cnt:, cnt:] -= 2.0 * np.outer(v, v)\n        R = np.dot(Q_cnt, R)  # R=H(n-1)...H(2)H(1)A\n        Q = np.dot(Q, Q_cnt)  # Q=H(1)H(2)...H(n)\n        z = np.dot(Q_cnt, z)  # z=H(n-1)...H(2)H(1)b \n   \n    # reduction\n    Q = Q[:r,:c]\n    R = R[:c,:c]\n    z = z[:c]\n    return Q,R,z\n\nA = np.array([[1, 5, 0],[5,","date":"2020-10-29","description":"","objectID":"/2020/the-qr-factorization/","tags":"QR分解","title":"The QR Factorization","uri":"/2020/the-qr-factorization/"},{"content":"\n\n\n![badge](https://img.shields.io/badge/Modern-Editor-green)\n\n使用现代化的编辑器vscode进行OpenFOAM编程的配置，大大提升编程体验。\n\u0026lt;!--more--\u0026gt;\n\n### 说明\n- 首先搜索扩展`c/c++`安装微软的的C++扩展\n\n- 打开工作文件夹，即你的OpenFOAM求解器存放的文件夹，按住`shift+ctrl+p`开启命令框，输入`c/c++:conf`后选择如图的第二条命令，生成`.vscode/c_cpp_properties.json`\n\n{{\u0026lt; figure src=\u0026#34;/images/vscode-openfoam/step1.png\u0026#34; \u0026gt;}}\n\n- 打开`Make/options`，可以看到所有需要包含的头文件，以`-I`开头\n\n{{\u0026lt; figure src=\u0026#34;/images/vscode-openfoam/step2.png\u0026#34; \u0026gt;}}\n\n值得注意的是，其中的`$(LIB_SRC)`所指的地址就是OpenFOAM源代码路径。\n\n如果你不知道这个路径，终端下执行\n\n```\nsrc\npwd\n```\n打印出的内容就是`$LIB_SRC`\n\n**值得注意的是，`Make/options`中的头文件并不完整，还需要加入以下两个头文件：**\n```\n/opt/OpenFOAM/OpenFOAM-v1912/USERNAME/src/OpenFOAM/lnInclude\n/opt/OpenFOAM/OpenFOAM-v1912/USERNAME/src/OSspecific/POSIX/lnInclude\n```\n请自行搜索以上两个头文件在你的设备中的位置。\n\n- 接着把完整路径放到C++配置文件的`includePath`中：\n\n{{\u0026lt; figure src=\u0026#34;/images/vscode-openfoam/step3.png\u0026#34; \u0026gt;}}\n\n注意每条路径用`\u0026#34; \u0026#34;`括起来，行末加`,`（最后一行路径除外）\n\n- 接下来还有一些小工作要做，先`wmake`求解器，你会看到下面的输出：\n\n{{\u0026lt; figure src=\u0026#34;/images/vscode-openfoam/step4.png\u0026#34; \u0026gt;}}\n\n第一个参数`g++`说明`wmake`使用g++编译器，因此将g++的路径替换`compilerPath`中的内容，不知道g++路径？终端里`which g++`得到。后面`-std = c++11 -m64 ... -ftemplate-depth-100`是`compilerArgs`，\n大部分是规定了编译过程错误信息输出以及优化信息，其中，`-W`开头的参数规定了编译过程中错误信息如何输出，对于我们使用编辑器没有作用，`-std = c++ 11 -m64 -O3`这几个参数则规定了编译使用的C++标准和优化信息，可以保留，而\n以`-D`参数开头的是一些宏定义，他们有的规定了所使用的精度等级，这些定义十分重要，如果不加会引起类型错误。最后`-ftemplate-depth-100`规定了实例化搜寻深度，默认值为900，所以如果不加应该也没有问题，但是对性能的影响尚不清楚。\n如果你觉得太麻烦，你可以将他们全都加到`compilerArgs`里\n\n{{\u0026lt; figure src=\u0026#34;/images/vscode-openfoam/step5.png\u0026#34; \u0026gt;}}\n\n- 最终效果：\n\n{{\u0026lt; figure src=\u0026#34;/images/vscode-openfoam/step6.png\u0026#34; \u0026gt;}}\n\n自动补全，代码提示、跳转都正常\n\n-----\n\n### NOTE\n- 由于OpenFOAM”特殊“的编程风格，常在头文件中写代码段而不是类声明等常规写法，会导致报错，比如头文件中`runTime`的`undefined`错误提示和`Info`的`ambigous`提示，目前没有解决方法。如果你不想看到这些错误提示，可以设置忽略，具体方法在网上很容易找到\n\n- 最近有个叫Volker Weissmann 的哥们在github上发起一个pull request, 介绍了一个叫做`ccls`的东西，似乎能够解决上面的问题，不过我还没尝试。[pull request](https://github.com/OpenFOAM/OpenFOAM-dev/pull/31)\n\n  {{\u0026lt; figure src=\u0026#34;/images/vscode-openfoam/mail.png\u0026#34; \u0026gt;}}\n\n- OpenFOAM的`.C .H`后缀可能使得Vscode识别语言类型错误，可以在`.vscode`下创建`settings.json`设置类型绑定，具体方法在网上很容易找到\n\n- 由于C++扩展进行intellisense会占用较大的存储空间，每打开一个工程，就会相应生成一个100Mb左右的预编译文件，但是对于intellisense没有作用。可以定期清理`~/.cache/vscode-cpptools/ipch`下的缓存文件来释放空间，或者在设置中把`intellisense cache size`设为0禁用。\n\n- 如果是wsl用户，可以使用wsl插件在vscode中调用bash，*上述操作均在vscode连接Ubuntu后进行*\n\n- 如果遇到问题请[点我][1]发起`issue`\n\n----\n\n### LICENSE\n\n本内容基于CC-BY-4.0 协议，转载请注明出处\n\n[1]:https://gitee.com/fr13ndsdp/Vscode-OpenFOAM/issues/new","date":"2020-10-29","description":"","objectID":"/2020/vscode-openfoam/","tags":"编程工具","title":"Happy FOAMing on VScode","uri":"/2020/vscode-openfoam/"},{"content":"\n多重网格简单示例\n\n\u0026lt;!--more--\u0026gt;\n\n### 基本理论\n\n考虑这样的线性方程组\n$$\n\\mathbf{A}\\vec{x} = \\vec{b}\n$$\n当使用标准迭代求解器（Gauss-Seidel，Jacobi，SOR）时，观察到收敛速度趋于“停顿”，即在几次迭代后无法有效减少误差，细化网格后，问题更加突出。 实际上，研究表明，收敛速度是误差场频率的函数，即误差从节点到节点的梯度。 如果误差以高频模式分布，则收敛速度很快。 然而，在最初的几次迭代之后，误差场被平滑（变为低频），使得收敛速度变差。\n\n一个显而易见的想法是：既然平滑后的误差在细网格上变为了低频，那么这个误差可以在粗网格上得到有效消除，因为细网格上的低频可能是粗网格上的高频！\n\n迭代得到的中间值设为$\\vec{y}$，则\n$$\n\\mathbf{A}\\vec{y} = \\vec{b} - \\vec{r}\n$$\n$\\vec{r}$为残差向量，如果用$\\vec{e} = \\vec{x} - \\vec{y}$表示中间值和解之间的距离，则\n$$\n\\mathbf{A}\\vec{e} = \\vec{r}\n$$\n因此这个方程与原来要解的方程具有同样的系数矩阵，如果可以解出$\\vec{e}$，那么便可修正中间值。为了有效地达成这一目的，把上面的方程放到粗网格中计算，以快速光滑残差。在这之后，将$\\vec{e}$再投影回细网格来修正解，如此反复迭代。\n\n多重网格方法常用的几个名词：\n\n- `Agglomeration` ：所有的多重网格方法都需要在原始“精细”网格的基础上定义一系列粗网格。定义粗网格的过程涉及到所谓的聚集，即从原始网格中组合几个节点或控制量或系数，得到粗网格上的稀疏矩阵。\n- `Restriction`：利用插值方法将误差向量投影到粗网格上\n- `Prolongation`：Restriction的反过程\n\n多重网格法的两种形式：\n\n- Geometric multigrid：在几何多重网格中，生成了网格的层次结构。方程在每个级别上进行离散。 几何多重网格优于代数多重网格的优点是，对于非线性问题，前者应具有更好的性能，因为系统中的非线性通过重新离散化可以降低到粗糙的水平。\n- Algebraic multigrid：该算法被称为代数多重网格方案，因为生成的粗糙层方程没有使用任何几何或在粗糙层上的重新离散。这样做的优点是不需要生成或存储粗级别的网格，也不需要在粗级别上计算通量或源项。这一特性使得AMG对于非结构化网格的使用尤为重要。\n\n多重网格法的关键算子：\n\n- Prolongation算子$\\mathbf{P}$，将粗网格上的结果插值到细网格上\n\n- Restriction算子 $\\mathbf{R}$，$\\mathbf{R} = \\frac{1}{2}\\mathbf{P^T}$\n- 代数多重网格的粗网格矩阵：$\\mathbf{A_{2h}} = \\mathbf{R}\\mathbf{A_h}\\mathbf{P}$\n\n### 算例\n\n{{\u0026lt; figure src=\u0026#34;/images/multigrid-method/multigrid.png\u0026#34; title=\u0026#34;一个简单的导热问题\u0026#34; \u0026gt;}}\n\n一个带内热源的导热问题\n$$\nk\\frac{d^2T}{dx^2} + g = 0\n$$\n长度1m，截面积0.01$m^2$，$k = 5 W/m.K$，$q = 20 kW/m^3$\n\n离散过程很简单，最后得到一个三对角矩阵，可以使用TDMA直接求解，在这里将使用多重网格进行求解。\n\n- V型循环，三层网格，网格数依次为20、10、5\n- 最后一层使用TDMA直接求解\n- $\\mathbf{P}$和$\\mathbf{R}$都使用线性插值代替\n- 粗网格矩阵可以重新离散得到或者使用插值\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nk = 5\nq = 20e3\na = 0.01\nn = 20\nn2 = 10\nn3 = 5\ntl = 100\ntr = 500\nl = 1.0\n\n\ndef restrict(vec):\n    n = int(np.size(vec)/2)\n    vec_coarse = np.zeros(n)\n    for i in range(n):\n        vec_coarse[i] = (vec[2*i]+vec[2*i+1])/2\n\n    return vec_coarse\n\n\ndef prolong(vec):\n    n = np.size(vec)\n    vec_fine = np.ones(n*2)*vec[0]/2\n    for i in range(1, n*2):\n        if (i % 2 == 0):\n            vec_fine[i] = (vec[int(i/2) - 1] + vec[int(i/2)])/2\n        else:\n            vec_fine[i] = vec[int(i/2)]\n\n    return vec_fine\n\n\n# iter stands for itereation times\ndef gsIter(aw, ap, ae, su, phi, itr):\n    n = np.size(aw)\n    phi0 = phi\n    for i in range(itr):\n        phi[0] = (ae[0]*phi0[1]+su[0])/ap[0]\n        for i in range(n-1):\n            phi[i] = (aw[i]*phi[i-1]+ae[i]*phi0[i+1]+su[i])/ap[i]\n\n        phi[n-1] = (aw[n-1]*phi[n-2]+su[n-1])/ap[n-1]\n        for i in range(n):\n            phi0[i] = phi[i]\n\n    return phi\n\n\ndef residual(su, aw, ap, ae, phi):\n    n = np.size(su)\n    res = np.zeros(n)\n    for i in range(1, n-1):\n        res[i] = su[i] - (-aw[i]*phi[i-1]+ap[i]*phi[i]-ae[i]*phi[i+1])\n        res[0] = su[0] - ap[0]*phi[0] + ae[0]*phi[1]\n        res[n-1] = su[n-1] - ap[n-1]*phi[n-1] + aw[n-1]*phi[n-2]\n    return res\n\n\ndef getMatrix(num):\n    aw = np.zeros(num)\n    ap = np.zeros(num)\n    ae = np.zeros(num)\n    su = np.zeros(num)\n    for i in range(1, num-1):\n        aw[i] = k*a*num/l\n        ae[i] = aw[i]\n        su[i] = q*a*l/num\n        ap[i] = aw[i]+ae[i]\n\n    aw[0] = 0\n    ae[num-1] = 0\n    ae[0] = k*a*num/l\n    aw[num-1] = k*a*num/l\n    su[0] = q*a*l/n+2*k*a*num/l*tl\n    su[num-1] = q*a*l/n+2*k*a*num/l*tr\n    ap[0] = aw[0]+ae[0] + 2*k*a*num/l\n    ap[num-1] = aw[num-1]+ae[num-1] + 2*k*a*num/l\n    return aw, ap, ae, su\n\n\ndef sol(aw, ap, ae, su):\n    n = np.size(aw)\n    p = np.zeros(n)\n    q = np.zeros(n)\n    phi = np.zeros(n)\n    p[0] = ae[0]/ap[0]\n    q[0] = su[0]/ap[0]\n    for i in range(1, n):\n        p[i] = ae[i]/(ap[i] - aw[i]*p[i-1])\n        q[i] = (su[i] + aw[i]*q[i-1])/(ap[i]-aw[i]*p[i-1])\n\n    phi[n-1] = q[n-1]\n    for i in range(n-1, 0, -1):\n        phi[i-1] = p[i-1]*phi[i]+q[i-1]\n\n    return phi\n\n\nif __name__ == \u0026#39;__main__\u0026#39;:\n    # prepare matrix\n    aw, ap, ae, su = getMatrix(n)\n    aw2, ap2, ae2, su2 = getMatrix(int(n/2))\n    aw3, ap3, ae3, su3 = getMatrix(int(n/4))\n    phi = np.ones(n)*150\n    phi = gsIter(aw, ap, ae, su, phi, 3)\n\n    res = 1\n    cnt = 0\n    res_list = []\n    while(res \u0026gt; 1e-6):\n        # finest mesh\n        phi = gsIter(aw, ap, ae, su, phi, 2)\n        r = residual(su, aw, ap, ae, phi)\n        res = np.mean(r)\n        res_list.append(res)\n        cnt += 1\n        print(\u0026#34;iter: \u0026#34;, cnt, \u0026#34; res:\u0026#34;, res)\n        # ------------- restriction -----------------\n        r2 = restrict(r)\n        e2 = gsIter(aw2, ap2, ae2, r2, np.zeros(int(n/2)), 10)\n        r4 = residual(r2, aw2, ap2, ae2, e2)\n        rr = restrict(r4)\n        #e4 = gsIter(aw3,ap3,ae3,rr,np.zeros(int(n/4)),10)\n        e4 = sol(aw3, ap3, ae3, rr)\n        # ------------ prolongation -----------------\n        eff = prolong(e4)\n        e2 = e2+eff\n        e2 = gsIter(aw2, ap2, ae2, r2, e2, 2)\n        ef = prolong(e2)\n        phi = phi + ef\n\n    plt.yscale(\u0026#39;log\u0026#39;)\n    plt.figure(1)\n    plt.plot(res_list)\n    plt.show()\n```\n\n```\niter:  1  res: 11.511","date":"2020-10-25","description":"","objectID":"/2020/multigrid-algorithm/","tags":"Multi-grid","title":"Multigrid Method","uri":"/2020/multigrid-algorithm/"},{"content":"\nSIMPLE 算法在一维稳态无粘不可压流动问题中的应用\n\n\u0026lt;!--more--\u0026gt;\n\n#### 1.问题描述\n\n{{\u0026lt; figure src=\u0026#34;/images/simple-algorithm/problem.jpg\u0026#34; title=\u0026#34;一维简化喷管内流动\u0026#34; \u0026gt;}}\n- 流体密度 $\\rho = 1\\ kg/m^3$, 不可压缩，无粘流动\n- 喷管长度 $L = 0.2\\ m$\n- 喷管左右面积给定 $A_{A} = 0.5\\ m^2, A_{E} = 0.1\\ m^2$\n- 左边界：恒定动压 $10\\ Pa$，右边界：恒定静压$0\\ Pa$\n\n#### 2.控制方程\n\n- 质量守恒方程\n  \n  $$\n  \\frac{d}{dx}(\\rho A u) = 0\n  $$\n  \n- 动量方程\n  $$\n  \\rho u A \\frac{du}{dx} = -A\\frac{dp}{dx}\n  $$\n\n解析解可由伯努利定律得到\n$$\np_0 = p_{E} + 1/2\\rho M^2/(\\rho A_E)^2\n$$\n其中$M$为质量流量，可得到精确解为$0.44721\\ kg/s$\n\n#### 3.SIMPLE算法\n\nSemi-Implicit Method for Pressure Linked Equations.\n\n这是一个求解速度-压力耦合的经典迭代算法\n\n实施过程中需要注意的点：\n\n- 交错网格，速度网格落后于压力网格\n\n- 边界条件的处理，在本例中入口边界使用了延迟修正（deferred correction）增强迭代稳定性\n- 松弛因子的选取，一般取$\\alpha_u + \\alpha_p = 1$，压力松弛因子要取得相对小避免发散\n- 速度的松弛放在离散动量方程的求解中，压力松弛在解出压力修正值之后\n\n带有速度松弛的离散动量方程：\n$$\n\\frac{a_{i,J}}{\\alpha_u}u_{i,J} = \\sum a_{nb}u_{nb}+(p_{I-1,J} - p_{I,J})A_{i,J}+b_{i,J}+\\frac{(1-\\alpha_u)a_{i,J}}{\\alpha_u}u_{i,J}^{(n-1)}\n$$\n下面是一个代码不规范但是能说明具体实施过程的例程，对流项使用一阶迎风差分或者TVD格式（Van Leer） 。\n\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# the TDMA\ndef sol(aw, ap, ae, su):\n    n = np.size(aw)\n    p = np.zeros(n)\n    q = np.zeros(n)\n    phi = np.zeros(n)\n    p[0] = ae[0]/ap[0]\n    q[0] = su[0]/ap[0]\n    for i in range(1, n):\n        p[i] = ae[i]/(ap[i] - aw[i]*p[i-1])\n        q[i] = (su[i] + aw[i]*q[i-1])/(ap[i]-aw[i]*p[i-1])\n\n    phi[n-1] = q[n-1]\n    for i in range(n-1, 0, -1):\n        phi[i-1] = p[i-1]*phi[i]+q[i-1]\n\n    return phi\n\nrho = 1  # density\nL = 2   # length\nn = 100  # number of pressure nodals\nnu = n-1    # number of velocity nodals\ndx = L/n\np0 = 10  # inlet stagnation pressure\np_exit = 0  # oulet gauge pressure\nmass = []   # mass flow\nsp = [1]    # momentum residual (source of pressure Eq.)\nresidual = [] # list of residual\nm = 1  # guessed mass flow\n\n# matrix coeff and source term coeff\napu = np.zeros(nu)\nawu = np.zeros(nu)\naeu = np.zeros(nu)\nsuu = np.zeros(nu)\napp = np.zeros(n)\nawp = np.zeros(n)\naep = np.zeros(n)\nsup = np.zeros(n)\n\n# under-relaxation factor\nalpha_u = 0.8\nalpha_p = 0.3\n\nd = np.zeros(nu)  # A/ap\n\n# area of pressure node and velocity node\nAp = np.linspace(0.5, 0.1, n)\nAu = np.linspace(0.5-0.25/n, 0.1+0.25/n, nu)\n\n# initial guessed value\nu = np.zeros(nu)\nfor i in range(nu):\n    u[i] = m/(rho*Au[i])\n\np = np.linspace(p0, p_exit, n)\npf = np.zeros(n)  # Pressure correction value\n\nwhile(max(sp) \u0026gt; 1e-5):\n    sp = []\n    # velocity update\n    for i in range(1, nu-1):\n        awu[i] = rho*(u[i-1]+u[i])/2*Ap[i]  # F_w\n        aeu[i] = 0  # upwind scheme\n        apu[i] = rho*(u[i]+u[i+1])/2 * Ap[i+1]  # awu[i]+aeu[i]+ (F_e-F_w)\n        apu[i] = apu[i]/alpha_u  # velocity relaxation\n        suu[i] = Au[i]*(p[i]-p[i+1]) + (1-alpha_u)*apu[i]*u[i]\n        d[i] = Au[i]/apu[i]\n\n    apu[0] = rho*(u[0]+u[1])/2*Ap[1] + rho * \\\n        (u[0]*Au[0]/Ap[0])*Ap[0]*0.5*(Au[0]/Ap[0])**2\n    apu[0] = apu[0]/alpha_u  # velocity relaxation\n    suu[0] = Au[0]*(p0 - p[1])+rho*(u[0]*Au[0]/Ap[0])*Ap[0] * \\\n        (Au[0]/Ap[0])*u[0]+(1-alpha_u)*apu[0]*u[0]\n    d[0] = Au[0]/apu[0]\n\n    awu[nu-1] = rho*(u[nu-2]+u[nu-1])/2*Ap[nu-1]\n    apu[nu-1] = rho*u[nu-1]*Au[nu-1]*Au[nu-1]/Ap[n-1]\n    apu[nu-1] = apu[nu-1]/alpha_u  # velocity relaxation\n    suu[nu-1] = Au[nu-1]*(p[nu-1] - p[nu]) + (1-alpha_u)*apu[nu-1]*u[nu-1]\n    d[nu-1] = Au[nu-1]/apu[nu-1]\n\n    u = sol(awu, apu, aeu, suu)\n\n    # pressure update\n    for i in range(1, n-1):\n        awp[i] = rho*d[i-1]*Au[i-1]\n        aep[i] = rho*d[i]*Au[i]\n        app[i] = awp[i]+aep[i]\n        sup[i] = rho*u[i-1]*Au[i-1] - rho*u[i]*Au[i]\n        sp.append(abs(sup[i]))\n\n    # do not update boundary pressure\n    # so set app to none-zero number and set sup to zero\n    app[0] = 1\n    sup[0] = 0\n    app[n-1] = 1\n    sup[n-1] = 0\n    pf = sol(awp, app, aep, sup)\n\n    # under-relaxation of pressure\n    prev = p\n    p = p + pf\n    p[0] = p0 - 0.5*rho*u[0]*u[0]*(Au[0]/Ap[0])**2\n    p = (1-alpha_p)*prev + alpha_p*p\n\n    for i in range(nu):\n        u[i] = u[i]+d[i]*(pf[i]-pf[i+1])\n\n    # calculate mass flow\n    mass.append(rho*Au[0]*u[0])\n    residual.append(max(sp))\n\n\nplt.figure(1)\nplt.plot(mass)\nplt.title(\u0026#34;mass flow\u0026#34;)\nplt.figure(2)\nplt.yscale(\u0026#39;log\u0026#39;)\nplt.plot(residual)\nplt.title(\u0026#34;max residual\u0026#34;)\nprint(\u0026#34;mass flow:\u0026#34;, mass[-1])\nprint(\u0026#34;momentum residual:\u0026#34;, max(sp))\n```\n\n\u0026gt; mass flow: 0.4441588782980728 \n\u0026gt;\n\u0026gt; momentum residual: 8.626240521558692e-06\n\n\n{{\u0026lt; figure src=\u0026#34;/images/simple-algorithm/output_1_1.png\u0026#34; title=\u0026#34;质量流量\u0026#34; \u0026gt;}}\n\n\n{{\u0026lt; figure src=\u0026#34;/images/simple-algorithm/output_1_2.png\u0026#34; title=\u0026#34;最大绝对残差\u0026#34; \u0026gt;}}\n\n上面的代码使用一阶迎风格式，采用压力修正方程中源项的绝对值的最大值作为判断收敛依据，采用100个压力节点得到收敛解：质量流量$0.444\\ kg/s$，并得到了压力、速度的分布。\n\n不妨试一试使用Van Leer格式，如下\n$$\n\\phi_e = \\phi_P + \\frac{1}{2}\\Psi(r)(\\phi_E - \\phi_P)\n$$\n\n$$\nr = \\frac{\\phi_P - \\phi_W}{\\phi_E - \\phi_p}\n$$\n\n$$\n\\Psi(r) = \\frac{r+|r|}{1+r}\n$$\n\n{{\u0026lt; figure src=\u0026#34;/images/simple-algorithm/tvd.png\u0026#34; title=\u0026#34;Sweby\u0026#39;s diagram\u0026#34; \u0026gt;}}\n\n当$\\Psi(r)$取零时就转化","date":"2020-10-22","description":"","objectID":"/2020/simple-algorithm/","tags":"FVM\nSIMPLE","title":"Simple algorithm","uri":"/2020/simple-algorithm/"},{"content":"\n单调栈解法\n\n\u0026lt;!--more--\u0026gt;\n\n#### 题目\n\n请根据每日 `气温` 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。\n\n例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。\n\n提示：气温 列表长度的范围是 `[1, 30000]`。每个气温的值的均为华氏度，都是在 `[30, 100]` 范围内的整数。\n\n#### 单调栈解法\n\n维护一个栈，使得从栈底到栈顶始终是递增的，具体做法举例：\n\n假如列表`temperatures = [10,12,5,7,13,14]`\n\n- 首先10入栈，12比10大，10弹出，栈顶为12 `[12]`\n\n- 5比12小，入栈 `[12 5]`\n- 7比5大，5弹出，7入栈 `[12 7]`\n- 13比7大，7弹出，13比12大，12弹出，13入栈 `[13]`\n- 14比13大，13弹出，14入栈  `[14]`\n\n为了获取等待天数，在每个元素出栈时计算此元素与与之比较的元素的下标差。为简单起见，栈中存储下标而不是值。\n\n所以实际过程如下：\n\n{{\u0026lt; figure src=\u0026#34;/images/739-daily-temperatures/stack.jpg\u0026#34; title=\u0026#34;操作顺序\u0026#34; \u0026gt;}}\n\n代码：\n\n```c++\nclass Solution {\npublic:\n    vector\u0026lt;int\u0026gt; dailyTemperatures(vector\u0026lt;int\u0026gt;\u0026amp; T) {\n        stack\u0026lt;int\u0026gt; s;\n        int n = T.size();\n        // initionlize\n        vector\u0026lt;int\u0026gt; ans(n,0);\n        \n        for (int i=0; i\u0026lt; n; ++i) {\n            while(!s.empty() \u0026amp;\u0026amp; T[i] \u0026gt; T[s.top()]) {\n                int index = s.top();\n                // inside s are indexes\n                ans[index] = (i-s.top());\n                s.pop();\n            }\n            // got a small number, then push it to stack\n            s.push(i);\n        }\n        return ans;\n    }\n};\n```\n\n#### 复杂度分析\n\n- 时间复杂度：$O(N)$ ，温度列表的所有元素都将进栈一次\n- 空间复杂度:  $O(N)$，结果列表的长度为$N$","date":"2020-07-07","description":"","objectID":"/2020/739-daily-temperatures/","tags":"单调栈","title":"#739 每日温度","uri":"/2020/739-daily-temperatures/"},{"content":"\n#### 题目\n\n你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39; 。每个拨轮可以自由旋转：例如把 \u0026#39;9\u0026#39; 变为  \u0026#39;0\u0026#39;，\u0026#39;0\u0026#39; 变为 \u0026#39;9\u0026#39; 。每次旋转都只能旋转一个拨轮的一位数字。\n\n锁的初始数字为 \u0026#39;0000\u0026#39; ，一个代表四个拨轮的数字的字符串。\n\n列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。\n\n字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。\n\n```\n输入：deadends = [\u0026#34;0201\u0026#34;,\u0026#34;0101\u0026#34;,\u0026#34;0102\u0026#34;,\u0026#34;1212\u0026#34;,\u0026#34;2002\u0026#34;], target = \u0026#34;0202\u0026#34;\n输出：6\n解释：\n可能的移动序列为 \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;1000\u0026#34; -\u0026gt; \u0026#34;1100\u0026#34; -\u0026gt; \u0026#34;1200\u0026#34; -\u0026gt; \u0026#34;1201\u0026#34; -\u0026gt; \u0026#34;1202\u0026#34; -\u0026gt; \u0026#34;0202\u0026#34;。\n注意 \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;0001\u0026#34; -\u0026gt; \u0026#34;0002\u0026#34; -\u0026gt; \u0026#34;0102\u0026#34; -\u0026gt; \u0026#34;0202\u0026#34; 这样的序列是不能解锁的，\n因为当拨动到 \u0026#34;0102\u0026#34; 时这个锁就会被锁定。\n```\n\n提示：\n\n1. 死亡列表 deadends 的长度范围为 [1, 500]。\n2. 目标数字 target 不会在 deadends 之中。\n3. 每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 \u0026#39;0000\u0026#39; 到 \u0026#39;9999\u0026#39; 中产生。\n\n---\n\n#### 解法1.BFS\n\n直接BFS，不过要加一个集合来表示deadends和重复的pattern。使用`unordered_set\u0026lt;string\u0026gt;`来存储和查询。\n\n```c++\nclass Solution {\npublic:\n    string add(string s, int i)\n    {\n        if (s[i] == \u0026#39;9\u0026#39;)\n            s[i] = \u0026#39;0\u0026#39;;\n        else\n            s[i] = s[i]+1;\n        return s;\n    }\n    \n    string minus(string s, int i)\n    {\n        if (s[i] == \u0026#39;0\u0026#39;)\n            s[i] = \u0026#39;9\u0026#39;;\n        else\n            s[i] = s[i]-1;\n        return s;\n    }\n    \n    int openLock(vector\u0026lt;string\u0026gt;\u0026amp; deadends, string target) {\n        unordered_set\u0026lt;string\u0026gt; set(deadends.begin(),deadends.end());\n        if (set.find(\u0026#34;0000\u0026#34;)!=set.end())\n            return -1;\n        queue\u0026lt;string\u0026gt; q;\n        q.push(\u0026#34;0000\u0026#34;);\n        int step = 0;\n        \n        while (!q.empty())\n        {\n            int n = q.size();\n            for (int j=0; j\u0026lt;n; j++)\n            {\n                string front = q.front();\n                for (int i=0; i\u0026lt;4; i++)\n                {\n                    string a = add(front,i);\n                    if (set.find(a)!=set.end())\n                        continue;\n                    if (a == target)\n                        return step+1;\n                    if (!set.count(a))\n                    {\n                        q.push(a);\n                        set.insert(a);\n                    }\n                }\n                for (int i=0; i\u0026lt;4; i++) {\n                    string b = minus(front,i);\n                    if (set.find(b)!=set.end())\n                        continue;\n                    if (b == target)\n                        return step+1;\n                    if (!set.count(b))\n                    {\n                        q.push(b);\n                        set.insert(b);\n                    }\n                }\n                q.pop();\n            }\n            step+=1;\n        }\n        return -1;\n    }\n};\n```\n#### 解法2.双向BFS\n\n","date":"2020-07-02","description":"","objectID":"/2020/752-open-the-lock/","tags":"广度优先搜索\n双向BFS","title":"#752 Open the Lock","uri":"/2020/752-open-the-lock/"},{"content":"\nDHT11温湿度传感器的使用——C51代码\n\n\u0026lt;!--more--\u0026gt;\n\n### 测量参数\n\n测量范围：20-90% RH 0-50℃\n\n测湿精度：±5% RH\n\n测温精度：±2℃\n\n分辨力：1\n\n### 特性\n\n- 宽电压供电，3V~5.5V\n- 数据线接上拉电阻，当长度小于20m，使用5k电阻\n- 上电后有1s的不稳定状态\n- **DHT11 只有在接收到开始信号后才触发一次温湿度采集**，如果没有接收到主机发送复位信号，DHT11 不主动进行温湿度采集。当数据采集完毕且无开始信号后，DHT11 自动切换到低速模式。\n\n### 时序\n\n{{\u0026lt; figure src=\u0026#34;/images/DHT11/sequential.png\u0026#34; title=\u0026#34;时序\u0026#34; \u0026gt;}}\n\n#### 1. 起始信号\n\n总线空闲状态为高电平，主机把总线拉低等待DHT11响应；\n\n与MCU相连的SDA数据引脚置为输出模式；\n\n主机把总线拉低至少18毫秒，然后拉高20-40us等待DHT返回响应信号；\n\n#### 2. 读取DHT11响应\n\nSDA数据引脚设为输入模式；\n\nDHT11检测到起始信号后，会将总线拉低80us，然后拉高80us作为响应；\n\n#### 3. 送出数据\n\nDHT11将送出40bit的数据\n\n**格式**: 40bit数据=8位湿度整数+8位湿度小数+8位温度整数+8位温度小数+8位校验，当温湿度数据和等于校验位时校验通过。\n\n似乎小数位全是零，而且整数数据的计算如下例所示\n\n`00011000 00000000` = 24.0\n\n因此通过循环移位接收高八位数据后转为字符串输出即可。\n\nDHT11 在拉高总线 80us 后开始传输数据。每 1bit 数据都以 50us 低电平时隙开始，告诉主机开始传输一位数据了。DHT11 以高电平的长短定义数据位是 0 还是 1，当 50us 低电平时隙过后拉高总线，高电平持续 26~28us 表示数据“0”；持续 70us 表示数据“1”。\n\n当最后 1bit 数据传送完毕后，DHT11 拉低总线 50us，表示数据传输完毕，随后总线由上拉电阻拉高进入空闲状态。\n\n### 代码\n\n```c\n#include \u0026lt;reg51.h\u0026gt;\n#include \u0026lt;intrins.h\u0026gt;\n\n#define uchar unsigned char\n#define uint unsigned int\n\nsbit Data=P1^0;   //定义数据线\nuchar rec_dat[12];   //用于显示的接收数据数组\n\nvoid DHT11_delay_ms(uint z)\n{\n   uint i,j;\n   for(i=z;i\u0026gt;0;i--)\n      for(j=110;j\u0026gt;0;j--);\n}\n\nvoid DHT11_start()  // 开始信号\n{\n   Data=1;\n   DHT11_delay_us(2);\n   Data=0;\n   DHT11_delay_ms(20);   //延时18ms以上\n   Data=1;\n   DHT11_delay_us(30);\n}\n\nuchar DHT11_rec_byte()      //接收一个字节\n{\n   uchar i,dat=0;\n  for(i=0;i\u0026lt;8;i++)    //从高到低依次接收8位数据\n   {          \n      while(!Data);   ////等待50us低电平过去\n      DHT11_delay_us(8);     //延时60us，如果还为高则数据为1，否则为0 \n      dat\u0026lt;\u0026lt;=1;           //移位使正确接收8位数据，数据为0时直接移位\n      if(Data==1)    //数据为1时，使dat加1来接收数据1\n         dat+=1;\n      while(Data);  //等待数据线拉低    \n    }  \n    return dat;\n}\n\nvoid DHT11_receive()      //接收40位的数据\n{\n    uchar R_H,R_L,T_H,T_L,RH,RL,TH,TL,revise; \n    DHT11_start(); // 向DHT11发送开始信号\n    if(Data==0) // DHT11先拉低后拉高总线作为响应\n    {\n        while(Data==0);   //等待拉高     \n        DHT11_delay_us(40);  //拉高后延时80us\n        R_H=DHT11_rec_byte();    //接收湿度高八位  \n        R_L=DHT11_rec_byte();    //接收湿度低八位  \n        T_H=DHT11_rec_byte();    //接收温度高八位  \n        T_L=DHT11_rec_byte();    //接收温度低八位\n        revise=DHT11_rec_byte(); //接收校正位\n\n        DHT11_delay_us(25);    //结束\n\n        if((R_H+R_L+T_H+T_L)==revise)      //校正\n        {\n            RH=R_H;\n            RL=R_L;\n            TH=T_H;\n            TL=T_L;\n        } \n        /*数据处理，方便显示*/\n        rec_dat[0]=\u0026#39;l\u0026#39;;\n        rec_dat[1]=\u0026#39;=\u0026#39;;\n        rec_dat[2]=\u0026#39;0\u0026#39;+(RH/10);\n        rec_dat[3]=\u0026#39;0\u0026#39;+(RH%10);\n        rec_dat[4]=\u0026#39;,\u0026#39;;\n        rec_dat[5]=\u0026#39;x\u0026#39;;\n        rec_dat[6]=\u0026#39;=\u0026#39;;\n        rec_dat[7]=\u0026#39;0\u0026#39;+(TH/10);\n        rec_dat[8]=\u0026#39;0\u0026#39;+(TH%10);\n        rec_dat[9]=\u0026#39;\\r\u0026#39;;\n        rec_dat[10] = \u0026#39;\\n\u0026#39;;\n        rec_dat[11] = \u0026#39;0\u0026#39;;\n    }\n}\n\nvoid main()\n{\n   UART_init(); // 串口初始化\n   DHT11_delay_ms(1500);    //DHT11上电后要等待1S以越过不稳定状态在此期间不能发送任何指令\n   while(1)\n   {\n       DHT11_receive();\n       UART_send_string(rec_dat); //串口发送数据\n       delay(); // 延时一定时间\n   }\n}\n```\n\n### UART传输设置\n\n```c\nvoid UART_init()\n{\n    // 波特率9600\n    SCON = 0X50; //工作于方式1  8位无校验异步通信的收发模式，并清空收发中断标志位\n    TMOD = 0X20; // 定时器1 8位自动加载计数器\n    // 定时器初值，与波特率有关\n    TH1 = 0XFD; \n    TL1 = 0XFD; \n\n    TR1 = 1; // 启动定时器1\n}\n\nvoid UART_send_byte(uchar dat) // 发送一个字节\n{\n    SBUF = dat;\n    while (TI == 0); // 等待直到发送成功\n    TI = 0;\n}\n\nvoid UART_send_string(uchar *buf) // 发送字符串\n{\n    while (*buf != \u0026#39;0\u0026#39;)\n    {\n        UART_send_byte(*buf++);\n    }\n}\n```\n\n","date":"2020-06-30","description":"","objectID":"/2020/dht11/","tags":"DHT11","title":"DHT11温湿度传感器——51单片机","uri":"/2020/dht11/"},{"content":"最佳解法：广度优先搜素\n\u0026lt;!--more--\u0026gt;\n\n\u0026gt; 给你一个由 `\u0026#39;1\u0026#39;`（陆地）和 `\u0026#39;0\u0026#39;`（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\u0026gt;\n\u0026gt; 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。\n\u0026gt;\n\u0026gt; 此外，你可以假设该网格的四条边均被水包围。\n\n示例:\n\n```\n输入:\n11110\n11010\n11000\n00000\n输出: 1\n```\n\n```\n输入:\n11000\n11000\n00100\n00011\n输出: 3\n解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。\n```\n\n**思路**：\n\n- 扫描一遍整个网格，遇到陆地就对他广度优先搜索，并将搜索到的全部陆地置为`0`，这样执行搜索的次数便是岛屿的数量。\n\n- 使用队列实现广搜，按照距离根节点距离递增的顺序遍历节点，遇到陆地则该点坐标入队，同时其上一个节点坐标出队，当队列为空时搜索完成。\n- 坐标点表示使用STL容器`pair\u0026lt;int,int\u0026gt;`，头文件`utility`\n- 时间复杂度$O(MN)$，扫描二维网格的时间复杂度\n- 最坏情况为全是陆地，因此空间复杂度$O(min(M,N))$\n\n**实现**\n\n```c++\nclass Solution {\npublic:\n    int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) {\n        int nr = grid.size();\n        // 经典陷阱\n        if (nr == 0)\n            return 0;\n        int nc = grid[0].size();\n        int num = 0;\n\n        for (int r=0; r \u0026lt; nr; r++) {\n            for (int c=0; c \u0026lt; nc; c++) {\n                if (grid[r][c] == \u0026#39;1\u0026#39;) {\n                    // 遇到根节点为陆地，岛屿加一\n                    num++;\n                    grid[r][c] = \u0026#39;0\u0026#39;;\n                    // 节点坐标\n                    queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; q;\n                    q.push({r,c});\n                    // 广搜\n                    while(!q.empty()) {\n                        auto rc = q.front();\n                        int row = rc.first, col = rc.second;\n                        // 访问四个邻接点\n                        if (row+1 \u0026lt; nr \u0026amp;\u0026amp; grid[row+1][col] == \u0026#39;1\u0026#39;) {\n                            grid[row+1][col] = \u0026#39;0\u0026#39;;\n                            q.push({row+1,col});\n                        }\n                        if (row-1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[row-1][col] == \u0026#39;1\u0026#39;) {\n                            grid[row-1][col] = \u0026#39;0\u0026#39;;\n                            q.push({row-1,col});\n                        }\n                        if (col+1 \u0026lt; nc \u0026amp;\u0026amp; grid[row][col+1] == \u0026#39;1\u0026#39;) {\n                            grid[row][col+1] = \u0026#39;0\u0026#39;;\n                            q.push({row,col+1});\n                        }\n                        if (col-1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[row][col-1] == \u0026#39;1\u0026#39;) {\n                            grid[row][col-1] = \u0026#39;0\u0026#39;;\n                            q.push({row,col-1});\n                        }\n                        q.pop();\n                    }\n                }\n            }\n        }\n        return num;\n    }\n};\n```\n\n**总结**\n\n广搜的实现还是较为容易，第一次做时以为只需要向根节点右下方遍历就行了，结果遇到了特例：*工字形* 的岛屿等，如\n\n```\n111\n010\n111\n```\n\n若是只向右下方搜索就会得出岛屿为2。\n\n","date":"2020-06-28","description":"","objectID":"/2020/200-number-of-islands/","tags":"广度优先搜索\n队列","title":"#200 岛屿数量","uri":"/2020/200-number-of-islands/"},{"content":"\n使用HUGO+Github Pages搭建个人博客\n\n\u0026lt;!--more--\u0026gt;\n\n## 安装HUGO\n\n由于WSL2的LocalHost和主机不一样，导致没办法本地预览，我放弃了在WSL上安装hugo，而是安装在Windows上，然后通过WSL调用`hugo.exe`来完成工作流。\n\n在 [HUGO的github仓库](https://github.com/gohugoio/hugo/) 下载windows Release版本，由于下载的很慢，我使用github镜像 [link](https://github.wuyanzheshui.workers.dev/) 来下载然后把hugo.exe的路径添加到系统环境变量。终端里执行\n\n```bash\nhugo.exe version\n```\n\n打印版本信息，一切正常。\n\n## 配置\n```bash\nhugo new site /path/to/site\n```\n\n后，将建立一个文件夹，结构如下\n\n```\n.\n├── archetypes\n├── config.toml\n├── content\n├── data\n├── layouts\n├── resources\n├── static\n└── themes\n```\n\n首先要安装一个主题，我选择了`LoveIt`主题，[仓库地址](https://github.com/dillonzq/LoveIt/ )。\n\n```bash\ngit clone git@github.com:dillonzq/LoveIt.git themes/LoveIt\n```\n\n然后需要编辑`config.toml`，我直接把`/themes/LoveIt/exampleSite`里的给复制了过来，然后略加一点修改就行了。注释非常详尽，参照着改就行了。[link](https://hugoloveit.com/)的文档就更加详尽了，以后遇到坑再看吧。\n\n`static`用来放图片，`aechetypes`里的`default.md`在每次创建文章的时候自动加一个模板。\n\n## 发布内容\n\n```bash\nhugo new posts/post.md\n```\n确认要发布后，然后把`draft:true` 改为`false`\n\n然后\n\n```bash\nhugo server\n```\n\n就可以在1313端口预览网页了。\n\n## 部署到Github Pages\n\n1. 创建github仓库，名字为`UserName.github.io`\n2. 进入`public`文件夹，执行`git init`，`git remote add xxx`\n3. 将`public`文件夹内容`push`到github\n\n","date":"2020-06-24","description":"","objectID":"/2020/hugo-go/","tags":"HUGO","title":"HUGO搭建博客","uri":"/2020/hugo-go/"},{"content":"\n\n\n\u0026gt; Talk is cheap, give it a shot.\n\n\n{{\u0026lt; music server=\u0026#34;netease\u0026#34; type=\u0026#34;song\u0026#34; id=\u0026#34;26468752\u0026#34; \u0026gt;}}\n","date":"2019-08-02","description":"","objectID":"/about/","tags":"","title":"which Fr13ndSDP","uri":"/about/"}]